//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

namespace OpenBankingApi.Client
{
    #pragma warning disable

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class Client 
    {
        private string _baseUrl = "";
        private System.Net.Http.HttpClient _httpClient;
        private System.Lazy<Newtonsoft.Json.JsonSerializerSettings> _settings;
    
        public Client(string baseUrl, System.Net.Http.HttpClient httpClient)
        {
            BaseUrl = baseUrl; 
            _httpClient = httpClient; 
            _settings = new System.Lazy<Newtonsoft.Json.JsonSerializerSettings>(() => 
            {
                var settings = new Newtonsoft.Json.JsonSerializerSettings();
                UpdateJsonSerializerSettings(settings);
                return settings;
            });
        }
    
        public string BaseUrl 
        {
            get { return _baseUrl; }
            set { _baseUrl = value; }
        }
    
        protected Newtonsoft.Json.JsonSerializerSettings JsonSerializerSettings { get { return _settings.Value; } }
    
        partial void UpdateJsonSerializerSettings(Newtonsoft.Json.JsonSerializerSettings settings);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);
    
        /// <summary>Get Accounts</summary>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Accounts Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadAccount3> GetAccountsAsync(string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent)
        {
            return GetAccountsAsync(x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Accounts</summary>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Accounts Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadAccount3> GetAccountsAsync(string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts");
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadAccount3); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadAccount3>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not found", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadAccount3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Accounts</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Accounts Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadAccount3> GetAccountsAccountIdAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent)
        {
            return GetAccountsAccountIdAsync(accountId, x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Accounts</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Accounts Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadAccount3> GetAccountsAccountIdAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts/{AccountId}");
            urlBuilder_.Replace("{AccountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadAccount3); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadAccount3>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadAccount3);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Balances</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Balances Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadBalance1> GetAccountsAccountIdBalancesAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent)
        {
            return GetAccountsAccountIdBalancesAsync(accountId, x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Balances</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Balances Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadBalance1> GetAccountsAccountIdBalancesAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts/{AccountId}/balances");
            urlBuilder_.Replace("{AccountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadBalance1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadBalance1>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadBalance1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Statements</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="fromStatementDateTime">The UTC ISO 8601 Date Time to filter statements FROM
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="toStatementDateTime">The UTC ISO 8601 Date Time to filter statements TO
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Statements Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadStatement1> GetAccountsAccountIdStatementsAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, System.DateTimeOffset? fromStatementDateTime, System.DateTimeOffset? toStatementDateTime, string x_customer_user_agent)
        {
            return GetAccountsAccountIdStatementsAsync(accountId, x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, fromStatementDateTime, toStatementDateTime, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Statements</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="fromStatementDateTime">The UTC ISO 8601 Date Time to filter statements FROM
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="toStatementDateTime">The UTC ISO 8601 Date Time to filter statements TO
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Statements Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadStatement1> GetAccountsAccountIdStatementsAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, System.DateTimeOffset? fromStatementDateTime, System.DateTimeOffset? toStatementDateTime, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts/{AccountId}/statements?");
            urlBuilder_.Replace("{AccountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fromStatementDateTime != null) 
            {
                urlBuilder_.Append("fromStatementDateTime=").Append(System.Uri.EscapeDataString(fromStatementDateTime.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (toStatementDateTime != null) 
            {
                urlBuilder_.Append("toStatementDateTime=").Append(System.Uri.EscapeDataString(toStatementDateTime.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadStatement1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadStatement1>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not found", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadStatement1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Statements</summary>
        /// <param name="statementId">StatementId</param>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Statements Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadStatement1> GetAccountsAccountIdStatementsStatementIdAsync(string statementId, string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent)
        {
            return GetAccountsAccountIdStatementsStatementIdAsync(statementId, accountId, x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Statements</summary>
        /// <param name="statementId">StatementId</param>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Statements Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadStatement1> GetAccountsAccountIdStatementsStatementIdAsync(string statementId, string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            if (statementId == null)
                throw new System.ArgumentNullException("statementId");
    
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts/{AccountId}/statements/{StatementId}");
            urlBuilder_.Replace("{StatementId}", System.Uri.EscapeDataString(ConvertToString(statementId, System.Globalization.CultureInfo.InvariantCulture)));
            urlBuilder_.Replace("{AccountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadStatement1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadStatement1>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not found", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadStatement1);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        /// <summary>Get Transactions</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="fromBookingDateTime">The UTC ISO 8601 Date Time to filter transactions FROM
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="toBookingDateTime">The UTC ISO 8601 Date Time to filter transactions TO
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Transactions Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        public System.Threading.Tasks.Task<OBReadTransaction4> GetAccountsAccountIdTransactionsAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, System.DateTimeOffset? fromBookingDateTime, System.DateTimeOffset? toBookingDateTime, string x_customer_user_agent)
        {
            return GetAccountsAccountIdTransactionsAsync(accountId, x_fapi_financial_id, x_fapi_customer_last_logged_time, x_fapi_customer_ip_address, x_fapi_interaction_id, authorization, fromBookingDateTime, toBookingDateTime, x_customer_user_agent, System.Threading.CancellationToken.None);
        }
    
        /// <summary>Get Transactions</summary>
        /// <param name="accountId">AccountId</param>
        /// <param name="x_fapi_financial_id">The unique id of the ASPSP to which the request is issued. The unique id will be issued by OB.</param>
        /// <param name="x_fapi_customer_last_logged_time">The time when the PSU last logged in with the TPP. 
        /// All dates in the HTTP headers are represented as RFC 7231 Full Dates. An example is below: 
        /// Sun, 10 Sep 2017 19:43:31 UTC</param>
        /// <param name="x_fapi_customer_ip_address">The PSU's IP address if the PSU is currently logged in with the TPP.</param>
        /// <param name="x_fapi_interaction_id">An RFC4122 UID used as a correlation id.</param>
        /// <param name="authorization">An Authorisation Token as per https://tools.ietf.org/html/rfc6750</param>
        /// <param name="fromBookingDateTime">The UTC ISO 8601 Date Time to filter transactions FROM
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="toBookingDateTime">The UTC ISO 8601 Date Time to filter transactions TO
        /// NB Time component is optional - set to 00:00:00 for just Date.
        /// If the Date Time contains a timezone, the ASPSP must ignore the timezone component.</param>
        /// <param name="x_customer_user_agent">Indicates the user-agent that the PSU is using.</param>
        /// <returns>Transactions Read</returns>
        /// <exception cref="SwaggerException">A server side error occurred.</exception>
        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        public async System.Threading.Tasks.Task<OBReadTransaction4> GetAccountsAccountIdTransactionsAsync(string accountId, string x_fapi_financial_id, string x_fapi_customer_last_logged_time, string x_fapi_customer_ip_address, string x_fapi_interaction_id, string authorization, System.DateTimeOffset? fromBookingDateTime, System.DateTimeOffset? toBookingDateTime, string x_customer_user_agent, System.Threading.CancellationToken cancellationToken)
        {
            if (accountId == null)
                throw new System.ArgumentNullException("accountId");
    
            var urlBuilder_ = new System.Text.StringBuilder();
            urlBuilder_.Append(BaseUrl != null ? BaseUrl.TrimEnd('/') : "").Append("/accounts/{AccountId}/transactions?");
            urlBuilder_.Replace("{AccountId}", System.Uri.EscapeDataString(ConvertToString(accountId, System.Globalization.CultureInfo.InvariantCulture)));
            if (fromBookingDateTime != null) 
            {
                urlBuilder_.Append("fromBookingDateTime=").Append(System.Uri.EscapeDataString(fromBookingDateTime.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            if (toBookingDateTime != null) 
            {
                urlBuilder_.Append("toBookingDateTime=").Append(System.Uri.EscapeDataString(toBookingDateTime.Value.ToString("s", System.Globalization.CultureInfo.InvariantCulture))).Append("&");
            }
            urlBuilder_.Length--;
    
            var client_ = _httpClient;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    if (x_fapi_financial_id == null)
                        throw new System.ArgumentNullException("x_fapi_financial_id");
                    request_.Headers.TryAddWithoutValidation("x-fapi-financial-id", ConvertToString(x_fapi_financial_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_last_logged_time != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-last-logged-time", ConvertToString(x_fapi_customer_last_logged_time, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_customer_ip_address != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-customer-ip-address", ConvertToString(x_fapi_customer_ip_address, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_fapi_interaction_id != null)
                        request_.Headers.TryAddWithoutValidation("x-fapi-interaction-id", ConvertToString(x_fapi_interaction_id, System.Globalization.CultureInfo.InvariantCulture));
                    if (authorization == null)
                        throw new System.ArgumentNullException("authorization");
                    request_.Headers.TryAddWithoutValidation("Authorization", ConvertToString(authorization, System.Globalization.CultureInfo.InvariantCulture));
                    if (x_customer_user_agent != null)
                        request_.Headers.TryAddWithoutValidation("x-customer-user-agent", ConvertToString(x_customer_user_agent, System.Globalization.CultureInfo.InvariantCulture));
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json; charset=utf-8"));
    
                    PrepareRequest(client_, request_, urlBuilder_);
                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);
                    PrepareRequest(client_, request_, url_);
    
                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    try
                    {
                        var headers_ = System.Linq.Enumerable.ToDictionary(response_.Headers, h_ => h_.Key, h_ => h_.Value);
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }
    
                        ProcessResponse(client_, response_);
    
                        var status_ = ((int)response_.StatusCode).ToString();
                        if (status_ == "200") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBReadTransaction4); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadTransaction4>(responseData_, _settings.Value);
                                return result_; 
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                        }
                        else
                        if (status_ == "400") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Bad request", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ == "401") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Unauthorized", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "403") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Forbidden", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "404") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not found", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "405") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Method Not Allowed", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "406") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Not Acceptable", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "429") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("Too Many Requests", (int)response_.StatusCode, responseData_, headers_, null);
                        }
                        else
                        if (status_ == "500") 
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            var result_ = default(OBErrorResponse1); 
                            try
                            {
                                result_ = Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(responseData_, _settings.Value);
                            } 
                            catch (System.Exception exception_) 
                            {
                                throw new SwaggerException("Could not deserialize the response body.", (int)response_.StatusCode, responseData_, headers_, exception_);
                            }
                            throw new SwaggerException<OBErrorResponse1>("Internal Server Error", (int)response_.StatusCode, responseData_, headers_, result_, null);
                        }
                        else
                        if (status_ != "200" && status_ != "204")
                        {
                            var responseData_ = response_.Content == null ? null : await response_.Content.ReadAsStringAsync().ConfigureAwait(false); 
                            throw new SwaggerException("The HTTP status code of the response was not expected (" + (int)response_.StatusCode + ").", (int)response_.StatusCode, responseData_, headers_, null);
                        }
            
                        return default(OBReadTransaction4);
                    }
                    finally
                    {
                        if (response_ != null)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
            }
        }
    
        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value is System.Enum)
            {
                string name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value;
                        }
                    }
                }
            }
            else if (value is bool) {
                return System.Convert.ToString(value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value != null && value.GetType().IsArray)
            {
                var array = System.Linq.Enumerable.OfType<object>((System.Array) value);
                return string.Join(",", System.Linq.Enumerable.Select(array, o => ConvertToString(o, cultureInfo)));
            }
        
            return System.Convert.ToString(value, cultureInfo);
        }
    }
    
    

    /// <summary>Unambiguous identification of the account to which credit and debit entries are made.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBAccount3 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Identification of the currency in which the account is held. 
        /// Usage: Currency should only be used in case one and the same account number covers several currencies
        /// and the initiating party needs to identify which currency needs to be used for settlement on the account.</summary>
        [Newtonsoft.Json.JsonProperty("Currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string Currency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountType1Code AccountType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountSubType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountSubType1Code AccountSubType { get; set; }
    
        /// <summary>Specifies the description of the account type.</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Description { get; set; }
    
        /// <summary>The nickname of the account, assigned by the account owner in order to provide an additional means of identification of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Nickname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Nickname { get; set; }
    
        /// <summary>Provides the details to identify an account.</summary>
        [Newtonsoft.Json.JsonProperty("Account", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBCashAccount5> Account { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Servicer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 Servicer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBAccount3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBAccount3>(data);
        }
    
    }
    
    /// <summary>Unambiguous identification of the account to which credit and debit entries are made.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBAccount3Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Identification of the currency in which the account is held. 
        /// Usage: Currency should only be used in case one and the same account number covers several currencies
        /// and the initiating party needs to identify which currency needs to be used for settlement on the account.</summary>
        [Newtonsoft.Json.JsonProperty("Currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string Currency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountType1Code AccountType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountSubType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountSubType1Code AccountSubType { get; set; }
    
        /// <summary>Specifies the description of the account type.</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Description { get; set; }
    
        /// <summary>The nickname of the account, assigned by the account owner in order to provide an additional means of identification of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Nickname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Nickname { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBAccount3Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBAccount3Basic>(data);
        }
    
    }
    
    /// <summary>Unambiguous identification of the account to which credit and debit entries are made.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBAccount3Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Identification of the currency in which the account is held. 
        /// Usage: Currency should only be used in case one and the same account number covers several currencies
        /// and the initiating party needs to identify which currency needs to be used for settlement on the account.</summary>
        [Newtonsoft.Json.JsonProperty("Currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string Currency { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountType1Code AccountType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountSubType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalAccountSubType1Code AccountSubType { get; set; }
    
        /// <summary>Specifies the description of the account type.</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Description { get; set; }
    
        /// <summary>The nickname of the account, assigned by the account owner in order to provide an additional means of identification of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Nickname", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Nickname { get; set; }
    
        /// <summary>Provides the details to identify an account.</summary>
        [Newtonsoft.Json.JsonProperty("Account", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OBCashAccount5> Account { get; set; } = new System.Collections.ObjectModel.Collection<OBCashAccount5>();
    
        [Newtonsoft.Json.JsonProperty("Servicer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 Servicer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBAccount3Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBAccount3Detail>(data);
        }
    
    }
    
    /// <summary>Amount of money of the cash balance after a transaction entry is applied to the account..</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBActiveOrHistoricCurrencyAndAmount 
    {
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Amount { get; set; }
    
        /// <summary>A code allocated to a currency by a Maintenance Agency under an international identification scheme, as described in the latest edition of the international standard ISO 4217 "Codes for the representation of currencies and funds".</summary>
        [Newtonsoft.Json.JsonProperty("Currency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string Currency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBActiveOrHistoricCurrencyAndAmount FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBActiveOrHistoricCurrencyAndAmount>(data);
        }
    
    }
    
    /// <summary>Identifies the nature of the postal address.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBAddressTypeCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Business")]
        Business = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Correspondence")]
        Correspondence = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"DeliveryTo")]
        DeliveryTo = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MailTo")]
        MailTo = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"POBox")]
        POBox = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Postal")]
        Postal = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Residential")]
        Residential = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Statement")]
        Statement = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBCAData1 
    {
        [Newtonsoft.Json.JsonProperty("ProductDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProductDetails ProductDetails { get; set; }
    
        /// <summary>Details about the interest that may be payable to the BCA account holders</summary>
        [Newtonsoft.Json.JsonProperty("CreditInterest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreditInterest CreditInterest { get; set; }
    
        /// <summary>Borrowing details</summary>
        [Newtonsoft.Json.JsonProperty("Overdraft", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Overdraft Overdraft { get; set; }
    
        /// <summary>Contains details of fees and charges which are not associated with either Overdraft or features/benefits</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeesCharges> OtherFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBCAData1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBCAData1>(data);
        }
    
    }
    
    /// <summary>Balance type, in a coded form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBBalanceType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ClosingAvailable")]
        ClosingAvailable = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ClosingBooked")]
        ClosingBooked = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ClosingCleared")]
        ClosingCleared = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Expected")]
        Expected = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ForwardAvailable")]
        ForwardAvailable = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Information")]
        Information = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"InterimAvailable")]
        InterimAvailable = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"InterimBooked")]
        InterimBooked = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"InterimCleared")]
        InterimCleared = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OpeningAvailable")]
        OpeningAvailable = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OpeningBooked")]
        OpeningBooked = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OpeningCleared")]
        OpeningCleared = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PreviouslyClosedBooked")]
        PreviouslyClosedBooked = 12,
    
    }
    
    /// <summary>Set of elements used to fully identify the type of underlying transaction resulting in an entry.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBankTransactionCodeStructure1 
    {
        /// <summary>Specifies the family within a domain.</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Code { get; set; }
    
        /// <summary>Specifies the sub-product family within a specific family.</summary>
        [Newtonsoft.Json.JsonProperty("SubCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SubCode { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBankTransactionCodeStructure1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBankTransactionCodeStructure1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBeneficiary3 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the beneficiary resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("BeneficiaryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string BeneficiaryId { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount5 CreditorAccount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBeneficiary3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBeneficiary3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBeneficiary3Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the beneficiary resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("BeneficiaryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string BeneficiaryId { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBeneficiary3Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBeneficiary3Basic>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBeneficiary3Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the beneficiary resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("BeneficiaryId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string BeneficiaryId { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBCashAccount5 CreditorAccount { get; set; } = new OBCashAccount5();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBeneficiary3Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBeneficiary3Detail>(data);
        }
    
    }
    
    /// <summary>Set of elements used to define the balance details.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBCashBalance1 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Indicates whether the balance is a credit or a debit balance. 
        /// Usage: A zero balance is considered to be a credit balance.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBBalanceType1Code Type { get; set; }
    
        /// <summary>Indicates the date (and time) of the balance.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("DateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset DateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        /// <summary>Set of elements used to provide details on the credit line.</summary>
        [Newtonsoft.Json.JsonProperty("CreditLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBCreditLine1> CreditLine { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBCashBalance1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBCashBalance1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBCreditDebitCode
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    /// <summary>Set of elements used to provide details on the credit line.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBCreditLine1 
    {
        /// <summary>Indicates whether or not the credit line is included in the balance of the account.
        /// Usage: If not present, credit line is not included in the balance amount of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Included", Required = Newtonsoft.Json.Required.Always)]
        public bool Included { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalLimitType1Code? Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBCreditLine1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBCreditLine1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details on the currency exchange.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBCurrencyExchange5 
    {
        /// <summary>Currency from which an amount is to be converted in a currency conversion.</summary>
        [Newtonsoft.Json.JsonProperty("SourceCurrency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string SourceCurrency { get; set; }
    
        /// <summary>Currency from which an amount is to be converted in a currency conversion.</summary>
        [Newtonsoft.Json.JsonProperty("TargetCurrency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string TargetCurrency { get; set; }
    
        /// <summary>Currency from which an amount is to be converted in a currency conversion.</summary>
        [Newtonsoft.Json.JsonProperty("UnitCurrency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{3,3}$")]
        public string UnitCurrency { get; set; }
    
        /// <summary>Factor used to convert an amount from one currency into another. This reflects the price at which one currency was bought with another currency.
        /// Usage: ExchangeRate expresses the ratio between UnitCurrency and QuotedCurrency (ExchangeRate = UnitCurrency/QuotedCurrency).</summary>
        [Newtonsoft.Json.JsonProperty("ExchangeRate", Required = Newtonsoft.Json.Required.Always)]
        public double ExchangeRate { get; set; }
    
        /// <summary>Unique identification to unambiguously identify the foreign exchange contract.</summary>
        [Newtonsoft.Json.JsonProperty("ContractIdentification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string ContractIdentification { get; set; }
    
        /// <summary>Date and time at which an exchange rate is quoted.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("QuotationDate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? QuotationDate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("InstructedAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount InstructedAmount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBCurrencyExchange5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBCurrencyExchange5>(data);
        }
    
    }
    
    /// <summary>Account to or from which a cash entry is made.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBDirectDebit1 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the direct debit resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("DirectDebitId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string DirectDebitId { get; set; }
    
        /// <summary>Direct Debit reference. For AUDDIS service users provide Core Reference. For non AUDDIS service users provide Core reference if possible or last used reference.</summary>
        [Newtonsoft.Json.JsonProperty("MandateIdentification", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string MandateIdentification { get; set; }
    
        [Newtonsoft.Json.JsonProperty("DirectDebitStatusCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalDirectDebitStatus1Code? DirectDebitStatusCode { get; set; }
    
        /// <summary>Name of Service User.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Date of most recent direct debit collection.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("PreviousPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? PreviousPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("PreviousPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount PreviousPaymentAmount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBDirectDebit1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBDirectDebit1>(data);
        }
    
    }
    
    /// <summary>Status of a transaction entry on the books of the account servicer.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBEntryStatus1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Booked")]
        Booked = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Pending")]
        Pending = 1,
    
    }
    
    /// <summary>Specifies the sub type of account (product family group).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalAccountSubType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ChargeCard")]
        ChargeCard = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CreditCard")]
        CreditCard = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CurrentAccount")]
        CurrentAccount = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EMoney")]
        EMoney = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Loan")]
        Loan = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Mortgage")]
        Mortgage = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PrePaidCard")]
        PrePaidCard = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Savings")]
        Savings = 7,
    
    }
    
    /// <summary>Specifies the type of account (personal or business).</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalAccountType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Business")]
        Business = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Personal")]
        Personal = 1,
    
    }
    
    /// <summary>The card authorisation type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalCardAuthorisationType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ConsumerDevice")]
        ConsumerDevice = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Contactless")]
        Contactless = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"None")]
        None = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PIN")]
        PIN = 3,
    
    }
    
    /// <summary>Name of the card scheme.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalCardSchemeType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AmericanExpress")]
        AmericanExpress = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Diners")]
        Diners = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Discover")]
        Discover = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MasterCard")]
        MasterCard = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"VISA")]
        VISA = 4,
    
    }
    
    /// <summary>Specifies the status of the direct debit in code form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalDirectDebitStatus1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Inactive")]
        Inactive = 1,
    
    }
    
    /// <summary>Limit type, in a coded form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalLimitType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Available")]
        Available = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Emergency")]
        Emergency = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Pre-Agreed")]
        PreAgreed = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Temporary")]
        Temporary = 4,
    
    }
    
    /// <summary>Offer type, in a coded form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalOfferType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BalanceTransfer")]
        BalanceTransfer = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"LimitIncrease")]
        LimitIncrease = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"MoneyTransfer")]
        MoneyTransfer = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PromotionalRate")]
        PromotionalRate = 4,
    
    }
    
    /// <summary>Party type, in a coded form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalPartyType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Delegate")]
        Delegate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Joint")]
        Joint = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Sole")]
        Sole = 2,
    
    }
    
    /// <summary>Specifies the Open Banking account access data types. This is a list of the data clusters being consented by the PSU, and requested for authorisation with the ASPSP.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalPermissions1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ReadAccountsBasic")]
        ReadAccountsBasic = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadAccountsDetail")]
        ReadAccountsDetail = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadBalances")]
        ReadBalances = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadBeneficiariesBasic")]
        ReadBeneficiariesBasic = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadBeneficiariesDetail")]
        ReadBeneficiariesDetail = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadDirectDebits")]
        ReadDirectDebits = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadOffers")]
        ReadOffers = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadPAN")]
        ReadPAN = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadParty")]
        ReadParty = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadPartyPSU")]
        ReadPartyPSU = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadProducts")]
        ReadProducts = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadScheduledPaymentsBasic")]
        ReadScheduledPaymentsBasic = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadScheduledPaymentsDetail")]
        ReadScheduledPaymentsDetail = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadStandingOrdersBasic")]
        ReadStandingOrdersBasic = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadStandingOrdersDetail")]
        ReadStandingOrdersDetail = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadStatementsBasic")]
        ReadStatementsBasic = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadStatementsDetail")]
        ReadStatementsDetail = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadTransactionsBasic")]
        ReadTransactionsBasic = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadTransactionsCredits")]
        ReadTransactionsCredits = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadTransactionsDebits")]
        ReadTransactionsDebits = 19,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ReadTransactionsDetail")]
        ReadTransactionsDetail = 20,
    
    }
    
    /// <summary>Descriptive code for the product category. 
    /// If ProductType - "Other" is chosen, the object OtherProductType must be populated with name, and description.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalProductType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"BusinessCurrentAccount")]
        BusinessCurrentAccount = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CommercialCreditCard")]
        CommercialCreditCard = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PersonalCurrentAccount")]
        PersonalCurrentAccount = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SMELoan")]
        SMELoan = 4,
    
    }
    
    /// <summary>Specifies the status of consent resource in code form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalRequestStatus1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Authorised")]
        Authorised = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AwaitingAuthorisation")]
        AwaitingAuthorisation = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Rejected")]
        Rejected = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Revoked")]
        Revoked = 3,
    
    }
    
    /// <summary>Specifies the scheduled payment date type requested</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalScheduleType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Arrival")]
        Arrival = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Execution")]
        Execution = 1,
    
    }
    
    /// <summary>Specifies the status of the standing order in code form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalStandingOrderStatus1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Active")]
        Active = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Inactive")]
        Inactive = 1,
    
    }
    
    /// <summary>Statement type, in a coded form.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OBExternalStatementType1Code
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosure")]
        AccountClosure = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Annual")]
        Annual = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Interim")]
        Interim = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"RegularPeriodic")]
        RegularPeriodic = 4,
    
    }
    
    /// <summary>Details of the merchant involved in the transaction.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBMerchantDetails1 
    {
        /// <summary>Name by which the merchant is known.</summary>
        [Newtonsoft.Json.JsonProperty("MerchantName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string MerchantName { get; set; }
    
        /// <summary>Category code conform to ISO 18245, related to the type of services or goods the merchant provides for the transaction.</summary>
        [Newtonsoft.Json.JsonProperty("MerchantCategoryCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4, MinimumLength = 3)]
        public string MerchantCategoryCode { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBMerchantDetails1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBMerchantDetails1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBOffer1 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the offer resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("OfferId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string OfferId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("OfferType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalOfferType1Code? OfferType { get; set; }
    
        /// <summary>Further details of the offer.</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(500, MinimumLength = 1)]
        public string Description { get; set; }
    
        /// <summary>Date and time at which the offer starts.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("StartDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? StartDateTime { get; set; }
    
        /// <summary>Date and time at which the offer ends.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("EndDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? EndDateTime { get; set; }
    
        /// <summary>Rate associated with the offer type.</summary>
        [Newtonsoft.Json.JsonProperty("Rate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(10, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string Rate { get; set; }
    
        /// <summary>Value associated with the offer type.</summary>
        [Newtonsoft.Json.JsonProperty("Value", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? Value { get; set; }
    
        /// <summary>Further details of the term of the offer.</summary>
        [Newtonsoft.Json.JsonProperty("Term", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(500, MinimumLength = 1)]
        public string Term { get; set; }
    
        /// <summary>URL (Uniform Resource Locator) where documentation on the offer can be found</summary>
        [Newtonsoft.Json.JsonProperty("URL", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength = 1)]
        public string URL { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Fee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount Fee { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBOffer1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBOffer1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBPCAData1 
    {
        [Newtonsoft.Json.JsonProperty("ProductDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProductDetails2 ProductDetails { get; set; }
    
        /// <summary>Details about the interest that may be payable to the PCA account holders</summary>
        [Newtonsoft.Json.JsonProperty("CreditInterest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public CreditInterest2 CreditInterest { get; set; }
    
        /// <summary>Details about Overdraft rates, fees & charges</summary>
        [Newtonsoft.Json.JsonProperty("Overdraft", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public Overdraft2 Overdraft { get; set; }
    
        /// <summary>Contains details of fees and charges which are not associated with either borrowing or features/benefits</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeesCharges2 OtherFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBPCAData1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBPCAData1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBParty1 
    {
        /// <summary>A unique and immutable identifier used to identify the customer resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("PartyId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string PartyId { get; set; }
    
        /// <summary>Number assigned by an agent to identify its customer.</summary>
        [Newtonsoft.Json.JsonProperty("PartyNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string PartyNumber { get; set; }
    
        [Newtonsoft.Json.JsonProperty("PartyType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalPartyType1Code? PartyType { get; set; }
    
        /// <summary>Name by which a party is known and which is usually used to identify that party.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Address for electronic mail (e-mail).</summary>
        [Newtonsoft.Json.JsonProperty("EmailAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength = 1)]
        public string EmailAddress { get; set; }
    
        /// <summary>Collection of information that identifies a phone number, as defined by telecom services.</summary>
        [Newtonsoft.Json.JsonProperty("Phone", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"\+[0-9]{1,3}-[0-9()+\-]{1,30}")]
        public string Phone { get; set; }
    
        /// <summary>Collection of information that identifies a mobile phone number, as defined by telecom services.</summary>
        [Newtonsoft.Json.JsonProperty("Mobile", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"\+[0-9]{1,3}-[0-9()+\-]{1,30}")]
        public string Mobile { get; set; }
    
        /// <summary>Postal address of a party.</summary>
        [Newtonsoft.Json.JsonProperty("Address", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBPostalAddress8> Address { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBParty1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBParty1>(data);
        }
    
    }
    
    /// <summary>Information that locates and identifies a specific address, as defined by postal services.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBPostalAddress6 
    {
        [Newtonsoft.Json.JsonProperty("AddressType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBAddressTypeCode? AddressType { get; set; }
    
        /// <summary>Identification of a division of a large organisation or building.</summary>
        [Newtonsoft.Json.JsonProperty("Department", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Department { get; set; }
    
        /// <summary>Identification of a sub-division of a large organisation or building.</summary>
        [Newtonsoft.Json.JsonProperty("SubDepartment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string SubDepartment { get; set; }
    
        /// <summary>Name of a street or thoroughfare.</summary>
        [Newtonsoft.Json.JsonProperty("StreetName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string StreetName { get; set; }
    
        /// <summary>Number that identifies the position of a building on a street.</summary>
        [Newtonsoft.Json.JsonProperty("BuildingNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(16, MinimumLength = 1)]
        public string BuildingNumber { get; set; }
    
        /// <summary>Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail.</summary>
        [Newtonsoft.Json.JsonProperty("PostCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(16, MinimumLength = 1)]
        public string PostCode { get; set; }
    
        /// <summary>Name of a built-up area, with defined boundaries, and a local government.</summary>
        [Newtonsoft.Json.JsonProperty("TownName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TownName { get; set; }
    
        /// <summary>Identifies a subdivision of a country such as state, region, county.</summary>
        [Newtonsoft.Json.JsonProperty("CountrySubDivision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string CountrySubDivision { get; set; }
    
        /// <summary>Nation with its own government.</summary>
        [Newtonsoft.Json.JsonProperty("Country", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{2,2}$")]
        public string Country { get; set; }
    
        /// <summary>Information that locates and identifies a specific address, as defined by postal services, presented in free format text.</summary>
        [Newtonsoft.Json.JsonProperty("AddressLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AddressLine { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBPostalAddress6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBPostalAddress6>(data);
        }
    
    }
    
    /// <summary>Postal address of a party.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBPostalAddress8 
    {
        [Newtonsoft.Json.JsonProperty("AddressType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBAddressTypeCode? AddressType { get; set; }
    
        /// <summary>Information that locates and identifies a specific address, as defined by postal services, that is presented in free format text.</summary>
        [Newtonsoft.Json.JsonProperty("AddressLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> AddressLine { get; set; }
    
        /// <summary>Name of a street or thoroughfare.</summary>
        [Newtonsoft.Json.JsonProperty("StreetName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string StreetName { get; set; }
    
        /// <summary>Number that identifies the position of a building on a street.</summary>
        [Newtonsoft.Json.JsonProperty("BuildingNumber", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(16, MinimumLength = 1)]
        public string BuildingNumber { get; set; }
    
        /// <summary>Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail.</summary>
        [Newtonsoft.Json.JsonProperty("PostCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(16, MinimumLength = 1)]
        public string PostCode { get; set; }
    
        /// <summary>Name of a built-up area, with defined boundaries, and a local government.</summary>
        [Newtonsoft.Json.JsonProperty("TownName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TownName { get; set; }
    
        /// <summary>Identifies a subdivision of a country eg, state, region, county.</summary>
        [Newtonsoft.Json.JsonProperty("CountrySubDivision", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string CountrySubDivision { get; set; }
    
        /// <summary>Nation with its own government, occupying a particular territory.</summary>
        [Newtonsoft.Json.JsonProperty("Country", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^[A-Z]{2,2}$")]
        public string Country { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBPostalAddress8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBPostalAddress8>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBProduct2 
    {
        /// <summary>The name of the product used for marketing purposes from a customer perspective. I.e. what the customer would recognise.</summary>
        [Newtonsoft.Json.JsonProperty("ProductName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string ProductName { get; set; }
    
        /// <summary>Identifier within the parent organisation for the product. Must be unique in the organisation.</summary>
        [Newtonsoft.Json.JsonProperty("ProductId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string ProductId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Identifier within the parent organisation for the product. Must be unique in the organisation.</summary>
        [Newtonsoft.Json.JsonProperty("SecondaryProductId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string SecondaryProductId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ProductType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalProductType1Code? ProductType { get; set; }
    
        /// <summary>Unique and unambiguous identification of a Product Marketing State.</summary>
        [Newtonsoft.Json.JsonProperty("MarketingStateId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string MarketingStateId { get; set; }
    
        [Newtonsoft.Json.JsonProperty("OtherProductType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBOtherProductType1 OtherProductType { get; set; }
    
        [Newtonsoft.Json.JsonProperty("BCA", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBCAData1 BCA { get; set; }
    
        [Newtonsoft.Json.JsonProperty("PCA", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBPCAData1 PCA { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBProduct2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBProduct2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadAccount3 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data Data { get; set; } = new Data();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadAccount3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadAccount3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadBalance1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data2 Data { get; set; } = new Data2();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadBalance1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadBalance1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadBeneficiary3 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data3 Data { get; set; } = new Data3();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadBeneficiary3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadBeneficiary3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadConsent1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBReadData1 Data { get; set; } = new OBReadData1();
    
        [Newtonsoft.Json.JsonProperty("Risk", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBRisk2 Risk { get; set; } = new OBRisk2();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadConsent1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadConsent1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadConsentResponse1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data4 Data { get; set; } = new Data4();
    
        [Newtonsoft.Json.JsonProperty("Risk", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBRisk2 Risk { get; set; } = new OBRisk2();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadConsentResponse1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadConsentResponse1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadData1 
    {
        /// <summary>Specifies the Open Banking account access data types. This is a list of the data clusters being consented by the PSU, and requested for authorisation with the ASPSP.</summary>
        [Newtonsoft.Json.JsonProperty("Permissions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OBExternalPermissions1Code> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<OBExternalPermissions1Code>();
    
        /// <summary>Specified date and time the permissions will expire.
        /// If this is not populated, the permissions will be open ended.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ExpirationDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpirationDateTime { get; set; }
    
        /// <summary>Specified start date and time for the transaction query period.
        /// If this is not populated, the start date will be open ended, and data will be returned from the earliest available transaction.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("TransactionFromDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TransactionFromDateTime { get; set; }
    
        /// <summary>Specified end date and time for the transaction query period.
        /// If this is not populated, the end date will be open ended, and data will be returned to the latest available transaction.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("TransactionToDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TransactionToDateTime { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadData1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadData1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadDirectDebit1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data5 Data { get; set; } = new Data5();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadDirectDebit1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadDirectDebit1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadOffer1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data6 Data { get; set; } = new Data6();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadOffer1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadOffer1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadParty1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data7 Data { get; set; } = new Data7();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadParty1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadParty1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadProduct2 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data8 Data { get; set; } = new Data8();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadProduct2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadProduct2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadScheduledPayment2 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data9 Data { get; set; } = new Data9();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadScheduledPayment2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadScheduledPayment2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadStandingOrder4 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data10 Data { get; set; } = new Data10();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadStandingOrder4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadStandingOrder4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadStatement1 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data11 Data { get; set; } = new Data11();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadStatement1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadStatement1>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBReadTransaction4 
    {
        [Newtonsoft.Json.JsonProperty("Data", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Data12 Data { get; set; } = new Data12();
    
        [Newtonsoft.Json.JsonProperty("Links", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Links Links { get; set; } = new Links();
    
        [Newtonsoft.Json.JsonProperty("Meta", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public Meta Meta { get; set; } = new Meta();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBReadTransaction4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBReadTransaction4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBScheduledPayment2 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the scheduled payment resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string ScheduledPaymentId { get; set; }
    
        /// <summary>The date on which the scheduled payment will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ScheduledPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ScheduledType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalScheduleType1Code ScheduledType { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("InstructedAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount InstructedAmount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount5 CreditorAccount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBScheduledPayment2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBScheduledPayment2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBScheduledPayment2Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the scheduled payment resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string ScheduledPaymentId { get; set; }
    
        /// <summary>The date on which the scheduled payment will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ScheduledPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ScheduledType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalScheduleType1Code ScheduledType { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("InstructedAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount InstructedAmount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBScheduledPayment2Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBScheduledPayment2Basic>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBScheduledPayment2Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the scheduled payment resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string ScheduledPaymentId { get; set; }
    
        /// <summary>The date on which the scheduled payment will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ScheduledPaymentDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset ScheduledPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("ScheduledType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalScheduleType1Code ScheduledType { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("InstructedAmount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount InstructedAmount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBCashAccount5 CreditorAccount { get; set; } = new OBCashAccount5();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBScheduledPayment2Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBScheduledPayment2Detail>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStandingOrder4 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the standing order resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("StandingOrderId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StandingOrderId { get; set; }
    
        /// <summary>Individual Definitions:
        /// EvryDay - Every day
        /// EvryWorkgDay - Every working day
        /// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
        /// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
        /// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
        /// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED)
        /// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December. 
        /// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
        /// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December. 
        /// Individual Patterns:
        /// EvryDay (ScheduleCode)
        /// EvryWorkgDay (ScheduleCode)
        /// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
        /// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
        /// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
        /// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
        /// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
        /// EvryDay
        /// EvryWorkgDay
        /// IntrvlWkDay:0[1-9]:0[1-7]
        /// WkInMnthDay:0[1-5]:0[1-7]
        /// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
        /// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
        /// Full Regular Expression:
        /// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$</summary>
        [Newtonsoft.Json.JsonProperty("Frequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$")]
        public string Frequency { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        /// <summary>The date on which the first payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FirstPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FirstPaymentDateTime { get; set; }
    
        /// <summary>The date on which the next payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("NextPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? NextPaymentDateTime { get; set; }
    
        /// <summary>The date on which the final payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FinalPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinalPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("StandingOrderStatusCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStandingOrderStatus1Code? StandingOrderStatusCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FirstPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FirstPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("NextPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount NextPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FinalPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FinalPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount5 CreditorAccount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStandingOrder4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStandingOrder4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStandingOrder4Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the standing order resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("StandingOrderId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StandingOrderId { get; set; }
    
        /// <summary>Individual Definitions:
        /// EvryDay - Every day
        /// EvryWorkgDay - Every working day
        /// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
        /// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
        /// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
        /// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED)
        /// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December. 
        /// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
        /// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December. 
        /// Individual Patterns:
        /// EvryDay (ScheduleCode)
        /// EvryWorkgDay (ScheduleCode)
        /// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
        /// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
        /// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
        /// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
        /// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
        /// EvryDay
        /// EvryWorkgDay
        /// IntrvlWkDay:0[1-9]:0[1-7]
        /// WkInMnthDay:0[1-5]:0[1-7]
        /// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
        /// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
        /// Full Regular Expression:
        /// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$</summary>
        [Newtonsoft.Json.JsonProperty("Frequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$")]
        public string Frequency { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        /// <summary>The date on which the first payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FirstPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FirstPaymentDateTime { get; set; }
    
        /// <summary>The date on which the next payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("NextPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? NextPaymentDateTime { get; set; }
    
        /// <summary>The date on which the final payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FinalPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinalPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("StandingOrderStatusCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStandingOrderStatus1Code? StandingOrderStatusCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FirstPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FirstPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("NextPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount NextPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FinalPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FinalPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStandingOrder4Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStandingOrder4Basic>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStandingOrder4Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>A unique and immutable identifier used to identify the standing order resource. This identifier has no meaning to the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("StandingOrderId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StandingOrderId { get; set; }
    
        /// <summary>Individual Definitions:
        /// EvryDay - Every day
        /// EvryWorkgDay - Every working day
        /// IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07)
        /// WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07)
        /// IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31)
        /// QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED)
        /// ENGLISH = Paid on the 25th March, 24th June, 29th September and 25th December. 
        /// SCOTTISH = Paid on the 2nd February, 15th May, 1st August and 11th November.
        /// RECEIVED = Paid on the 20th March, 19th June, 24th September and 20th December. 
        /// Individual Patterns:
        /// EvryDay (ScheduleCode)
        /// EvryWorkgDay (ScheduleCode)
        /// IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek)
        /// WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek)
        /// IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth)
        /// QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay
        /// The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here:
        /// EvryDay
        /// EvryWorkgDay
        /// IntrvlWkDay:0[1-9]:0[1-7]
        /// WkInMnthDay:0[1-5]:0[1-7]
        /// IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01])
        /// QtrDay:(ENGLISH|SCOTTISH|RECEIVED)
        /// Full Regular Expression:
        /// ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$</summary>
        [Newtonsoft.Json.JsonProperty("Frequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$")]
        public string Frequency { get; set; }
    
        /// <summary>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction.
        /// Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money.
        /// If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor's reference or payment remittance identification should be quoted in the end-to-end transaction identification.</summary>
        [Newtonsoft.Json.JsonProperty("Reference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Reference { get; set; }
    
        /// <summary>The date on which the first payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FirstPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FirstPaymentDateTime { get; set; }
    
        /// <summary>The date on which the next payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("NextPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? NextPaymentDateTime { get; set; }
    
        /// <summary>The date on which the final payment for a Standing Order schedule will be made.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("FinalPaymentDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FinalPaymentDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("StandingOrderStatusCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStandingOrderStatus1Code? StandingOrderStatusCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FirstPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FirstPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("NextPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount NextPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FinalPaymentAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount FinalPaymentAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification5 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBCashAccount5 CreditorAccount { get; set; } = new OBCashAccount5();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStandingOrder4Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStandingOrder4Detail>(data);
        }
    
    }
    
    /// <summary>Provides further details on a statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatement1 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the statement resource within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("StatementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StatementId { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string StatementReference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStatementType1Code Type { get; set; }
    
        /// <summary>Date and time at which the statement period starts.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("StartDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDateTime { get; set; }
    
        /// <summary>Date and time at which the statement period ends.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("EndDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset EndDateTime { get; set; }
    
        /// <summary>Date and time at which the resource was created.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("CreationDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreationDateTime { get; set; }
    
        /// <summary>Other descriptions that may be available for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementDescription { get; set; }
    
        /// <summary>Set of elements used to provide details of a benefit or reward amount for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementBenefit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementBenefit1> StatementBenefit { get; set; }
    
        /// <summary>Set of elements used to provide details of a fee for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementFee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementFee1> StatementFee { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic interest amount related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementInterest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementInterest1> StatementInterest { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic date time for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementDateTime1> StatementDateTime { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic rate related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementRate1> StatementRate { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic number value related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementValue1> StatementValue { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic amount for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementAmount1> StatementAmount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatement1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatement1>(data);
        }
    
    }
    
    /// <summary>Provides further details on a statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatement1Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the statement resource within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("StatementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StatementId { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string StatementReference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStatementType1Code Type { get; set; }
    
        /// <summary>Date and time at which the statement period starts.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("StartDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDateTime { get; set; }
    
        /// <summary>Date and time at which the statement period ends.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("EndDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset EndDateTime { get; set; }
    
        /// <summary>Date and time at which the resource was created.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("CreationDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreationDateTime { get; set; }
    
        /// <summary>Other descriptions that may be available for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementDescription { get; set; }
    
        /// <summary>Set of elements used to provide details of a benefit or reward amount for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementBenefit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementBenefit1> StatementBenefit { get; set; }
    
        /// <summary>Set of elements used to provide details of a fee for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementFee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementFee1> StatementFee { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic interest amount related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementInterest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementInterest1> StatementInterest { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic date time for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementDateTime1> StatementDateTime { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic rate related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementRate1> StatementRate { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic number value related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementValue1> StatementValue { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatement1Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatement1Basic>(data);
        }
    
    }
    
    /// <summary>Provides further details on a statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatement1Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the statement resource within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("StatementId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string StatementId { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string StatementReference { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalStatementType1Code Type { get; set; }
    
        /// <summary>Date and time at which the statement period starts.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("StartDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StartDateTime { get; set; }
    
        /// <summary>Date and time at which the statement period ends.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("EndDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset EndDateTime { get; set; }
    
        /// <summary>Date and time at which the resource was created.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("CreationDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreationDateTime { get; set; }
    
        /// <summary>Other descriptions that may be available for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDescription", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementDescription { get; set; }
    
        /// <summary>Set of elements used to provide details of a benefit or reward amount for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementBenefit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementBenefit1> StatementBenefit { get; set; }
    
        /// <summary>Set of elements used to provide details of a fee for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementFee", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementFee1> StatementFee { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic interest amount related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementInterest", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementInterest1> StatementInterest { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic date time for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementDateTime1> StatementDateTime { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic rate related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementRate1> StatementRate { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic number value related to the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementValue", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementValue1> StatementValue { get; set; }
    
        /// <summary>Set of elements used to provide details of a generic amount for the statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("StatementAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatementAmount1> StatementAmount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatement1Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatement1Detail>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a generic amount for the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementAmount1 
    {
        /// <summary>Indicates whether the amount is a credit or a debit. 
        /// Usage: A zero amount is considered to be a credit amount.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator2 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementAmount1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementAmount1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a benefit or reward amount for the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementBenefit1 
    {
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementBenefit1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementBenefit1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a generic date time for the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementDateTime1 
    {
        /// <summary>Date and time associated with the date time type.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("DateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset DateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementDateTime1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementDateTime1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a fee for the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementFee1 
    {
        /// <summary>Indicates whether the amount is a credit or a debit. 
        /// Usage: A zero amount is considered to be a credit amount.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator3 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementFee1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementFee1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a generic interest amount related to the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementInterest1 
    {
        /// <summary>Indicates whether the amount is a credit or a debit. 
        /// Usage: A zero amount is considered to be a credit amount.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator4 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementInterest1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementInterest1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a generic rate related to the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementRate1 
    {
        /// <summary>Rate associated with the statement rate type.</summary>
        [Newtonsoft.Json.JsonProperty("Rate", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(10, MinimumLength = 1)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string Rate { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementRate1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementRate1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to provide details of a generic number value related to the statement resource.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBStatementValue1 
    {
        /// <summary>Value associated with the statement value type.</summary>
        [Newtonsoft.Json.JsonProperty("Value", Required = Newtonsoft.Json.Required.Always)]
        public int Value { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string Type { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBStatementValue1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBStatementValue1>(data);
        }
    
    }
    
    /// <summary>Provides further details on an entry in the report.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBTransaction4 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string TransactionId { get; set; }
    
        /// <summary>Unique reference for the transaction. This reference is optionally populated, and may as an example be the FPID in the Faster Payments context.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TransactionReference { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementReference { get; set; }
    
        /// <summary>Indicates whether the transaction is a credit or a debit entry.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator5 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBEntryStatus1Code Status { get; set; }
    
        /// <summary>Date and time when a transaction entry is posted to an account on the account servicer's books.
        /// Usage: Booking date is the expected booking date, unless the status is booked, in which case it is the actual booking date.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("BookingDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset BookingDateTime { get; set; }
    
        /// <summary>Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry.
        /// Usage: If transaction entry status is pending and value date is present, then the value date refers to an expected/requested value date.
        /// For transaction entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the number of availability days.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ValueDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValueDateTime { get; set; }
    
        /// <summary>Information that locates and identifies a specific address for a transaction entry, that is presented in free format text.</summary>
        [Newtonsoft.Json.JsonProperty("AddressLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string AddressLine { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        [Newtonsoft.Json.JsonProperty("ChargeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount ChargeAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CurrencyExchange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCurrencyExchange5 CurrencyExchange { get; set; }
    
        [Newtonsoft.Json.JsonProperty("BankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBankTransactionCodeStructure1 BankTransactionCode { get; set; }
    
        /// <summary>Set of elements to fully identify a proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("ProprietaryBankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProprietaryBankTransactionCode ProprietaryBankTransactionCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CardInstrument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBTransactionCardInstrument1 CardInstrument { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("TransactionInformation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TransactionInformation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBTransactionCashBalance Balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("MerchantDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBMerchantDetails1 MerchantDetails { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount6 CreditorAccount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("DebtorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 DebtorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("DebtorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount6 DebtorAccount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBTransaction4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBTransaction4>(data);
        }
    
    }
    
    /// <summary>Provides further details on an entry in the report.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBTransaction4Basic 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string TransactionId { get; set; }
    
        /// <summary>Unique reference for the transaction. This reference is optionally populated, and may as an example be the FPID in the Faster Payments context.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TransactionReference { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementReference { get; set; }
    
        /// <summary>Indicates whether the transaction is a credit or a debit entry.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator6 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBEntryStatus1Code Status { get; set; }
    
        /// <summary>Date and time when a transaction entry is posted to an account on the account servicer's books.
        /// Usage: Booking date is the expected booking date, unless the status is booked, in which case it is the actual booking date.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("BookingDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset BookingDateTime { get; set; }
    
        /// <summary>Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry.
        /// Usage: If transaction entry status is pending and value date is present, then the value date refers to an expected/requested value date.
        /// For transaction entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the number of availability days.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ValueDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValueDateTime { get; set; }
    
        /// <summary>Information that locates and identifies a specific address for a transaction entry, that is presented in free format text.</summary>
        [Newtonsoft.Json.JsonProperty("AddressLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string AddressLine { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        [Newtonsoft.Json.JsonProperty("ChargeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount ChargeAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CurrencyExchange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCurrencyExchange5 CurrencyExchange { get; set; }
    
        [Newtonsoft.Json.JsonProperty("BankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBankTransactionCodeStructure1 BankTransactionCode { get; set; }
    
        /// <summary>Set of elements to fully identify a proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("ProprietaryBankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProprietaryBankTransactionCode2 ProprietaryBankTransactionCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CardInstrument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBTransactionCardInstrument1 CardInstrument { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBTransaction4Basic FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBTransaction4Basic>(data);
        }
    
    }
    
    /// <summary>Provides further details on an entry in the report.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBTransaction4Detail 
    {
        [Newtonsoft.Json.JsonProperty("AccountId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string AccountId { get; set; }
    
        /// <summary>Unique identifier for the transaction within an servicing institution. This identifier is both unique and immutable.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionId", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string TransactionId { get; set; }
    
        /// <summary>Unique reference for the transaction. This reference is optionally populated, and may as an example be the FPID in the Faster Payments context.</summary>
        [Newtonsoft.Json.JsonProperty("TransactionReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string TransactionReference { get; set; }
    
        /// <summary>Unique reference for the statement. This reference may be optionally populated if available.</summary>
        [Newtonsoft.Json.JsonProperty("StatementReference", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> StatementReference { get; set; }
    
        /// <summary>Indicates whether the transaction is a credit or a debit entry.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator7 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBEntryStatus1Code Status { get; set; }
    
        /// <summary>Date and time when a transaction entry is posted to an account on the account servicer's books.
        /// Usage: Booking date is the expected booking date, unless the status is booked, in which case it is the actual booking date.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("BookingDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset BookingDateTime { get; set; }
    
        /// <summary>Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry.
        /// Usage: If transaction entry status is pending and value date is present, then the value date refers to an expected/requested value date.
        /// For transaction entries subject to availability/float and for which availability information is provided, the value date must not be used. In this case the availability component identifies the number of availability days.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ValueDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ValueDateTime { get; set; }
    
        /// <summary>Information that locates and identifies a specific address for a transaction entry, that is presented in free format text.</summary>
        [Newtonsoft.Json.JsonProperty("AddressLine", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string AddressLine { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        [Newtonsoft.Json.JsonProperty("ChargeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBActiveOrHistoricCurrencyAndAmount ChargeAmount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CurrencyExchange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCurrencyExchange5 CurrencyExchange { get; set; }
    
        [Newtonsoft.Json.JsonProperty("BankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBankTransactionCodeStructure1 BankTransactionCode { get; set; }
    
        /// <summary>Set of elements to fully identify a proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("ProprietaryBankTransactionCode", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public ProprietaryBankTransactionCode3 ProprietaryBankTransactionCode { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CardInstrument", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBTransactionCardInstrument1 CardInstrument { get; set; }
    
        [Newtonsoft.Json.JsonProperty("SupplementaryData", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBSupplementaryData1 SupplementaryData { get; set; }
    
        [Newtonsoft.Json.JsonProperty("TransactionInformation", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string TransactionInformation { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Balance", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBTransactionCashBalance Balance { get; set; }
    
        [Newtonsoft.Json.JsonProperty("MerchantDetails", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBMerchantDetails1 MerchantDetails { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 CreditorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("CreditorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount6 CreditorAccount { get; set; }
    
        [Newtonsoft.Json.JsonProperty("DebtorAgent", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBBranchAndFinancialInstitutionIdentification6 DebtorAgent { get; set; }
    
        [Newtonsoft.Json.JsonProperty("DebtorAccount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBCashAccount6 DebtorAccount { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBTransaction4Detail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBTransaction4Detail>(data);
        }
    
    }
    
    /// <summary>Set of elements to describe the card instrument used in the transaction.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBTransactionCardInstrument1 
    {
        [Newtonsoft.Json.JsonProperty("CardSchemeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalCardSchemeType1Code CardSchemeName { get; set; }
    
        [Newtonsoft.Json.JsonProperty("AuthorisationType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalCardAuthorisationType1Code? AuthorisationType { get; set; }
    
        /// <summary>Name of the cardholder using the card instrument.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Identification assigned by an institution to identify the card instrument used in the transaction. This identification is known by the account owner, and may be masked.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(34, MinimumLength = 1)]
        public string Identification { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBTransactionCardInstrument1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBTransactionCardInstrument1>(data);
        }
    
    }
    
    /// <summary>Set of elements used to define the balance as a numerical representation of the net increases and decreases in an account after a transaction entry is applied to the account.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBTransactionCashBalance 
    {
        /// <summary>Indicates whether the balance is a credit or a debit balance. 
        /// Usage: A zero balance is considered to be a credit balance.</summary>
        [Newtonsoft.Json.JsonProperty("CreditDebitIndicator", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CreditDebitIndicator8 CreditDebitIndicator { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Type", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBBalanceType1Code Type { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Amount", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public OBActiveOrHistoricCurrencyAndAmount Amount { get; set; } = new OBActiveOrHistoricCurrencyAndAmount();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBTransactionCashBalance FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBTransactionCashBalance>(data);
        }
    
    }
    
    /// <summary>This field provides extension to the ProductType enumeration.
    /// If ProductType - "Other" is chosen, this field must be populated with name, and description for ASPSP specific product type.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBOtherProductType1 
    {
        /// <summary>Name of "Other" product type.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description of "Other" product type.</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBOtherProductType1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBOtherProductType1>(data);
        }
    
    }
    
    /// <summary>Additional information that can not be captured in the structured fields and/or any other specific block.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBSupplementaryData1 
    {
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBSupplementaryData1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBSupplementaryData1>(data);
        }
    
    }
    
    /// <summary>Party that manages the account on behalf of the account owner, that is manages the registration and booking of entries on the account, calculates balances on the account and provides information about the account.
    /// This is the servicer of the beneficiary account.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBranchAndFinancialInstitutionIdentification5 
    {
        [Newtonsoft.Json.JsonProperty("SchemeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SchemeName { get; set; }
    
        /// <summary>Unique and unambiguous identification of the servicing institution.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBranchAndFinancialInstitutionIdentification5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBranchAndFinancialInstitutionIdentification5>(data);
        }
    
    }
    
    /// <summary>Provides the details to identify the beneficiary account.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBCashAccount5 
    {
        [Newtonsoft.Json.JsonProperty("SchemeName", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public string SchemeName { get; set; }
    
        /// <summary>Beneficiary account identification.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Name of the account, as assigned by the account servicing institution.
        /// Usage: The account name is the name or names of the account owner(s) represented at an account level. The account name is not the product name or the nickname of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>This is secondary identification of the account, as assigned by the account servicing institution. 
        /// This can be used by building societies to additionally identify accounts with a roll number (in addition to a sort code and account number combination).</summary>
        [Newtonsoft.Json.JsonProperty("SecondaryIdentification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(34, MinimumLength = 1)]
        public string SecondaryIdentification { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBCashAccount5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBCashAccount5>(data);
        }
    
    }
    
    /// <summary>Unambiguous identification of the account of the debtor, in the case of a crebit transaction.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBCashAccount6 
    {
        [Newtonsoft.Json.JsonProperty("SchemeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchemeName { get; set; }
    
        /// <summary>Identification assigned by an institution to identify an account. This identification is known by the account owner.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(256, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Name of the account, as assigned by the account servicing institution.
        /// Usage: The account name is the name or names of the account owner(s) represented at an account level. The account name is not the product name or the nickname of the account.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>This is secondary identification of the account, as assigned by the account servicing institution. 
        /// This can be used by building societies to additionally identify accounts with a roll number (in addition to a sort code and account number combination).</summary>
        [Newtonsoft.Json.JsonProperty("SecondaryIdentification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(34, MinimumLength = 1)]
        public string SecondaryIdentification { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBCashAccount6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBCashAccount6>(data);
        }
    
    }
    
    /// <summary>Financial institution servicing an account for the debtor.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBBranchAndFinancialInstitutionIdentification6 
    {
        [Newtonsoft.Json.JsonProperty("SchemeName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string SchemeName { get; set; }
    
        /// <summary>Unique and unambiguous identification of a financial institution or a branch of a financial institution.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Name by which an agent is known and which is usually used to identify that agent.</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(140, MinimumLength = 1)]
        public string Name { get; set; }
    
        [Newtonsoft.Json.JsonProperty("PostalAddress", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBPostalAddress6 PostalAddress { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBBranchAndFinancialInstitutionIdentification6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBBranchAndFinancialInstitutionIdentification6>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBError1 
    {
        /// <summary>Low level textual error code, e.g., UK.OBIE.Field.Missing</summary>
        [Newtonsoft.Json.JsonProperty("ErrorCode", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength = 1)]
        public string ErrorCode { get; set; }
    
        /// <summary>A description of the error that occurred. e.g., 'A mandatory field isn't supplied' or 'RequestedExecutionDateTime must be in future'
        /// OBIE doesn't standardise this field</summary>
        [Newtonsoft.Json.JsonProperty("Message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(500, MinimumLength = 1)]
        public string Message { get; set; }
    
        /// <summary>Recommended but optional reference to the JSON Path of the field with error, e.g., Data.Initiation.InstructedAmount.Currency</summary>
        [Newtonsoft.Json.JsonProperty("Path", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(500, MinimumLength = 1)]
        public string Path { get; set; }
    
        /// <summary>URL to help remediate the problem, or provide more information, or to API Reference, or help etc</summary>
        [Newtonsoft.Json.JsonProperty("Url", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public string Url { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBError1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBError1>(data);
        }
    
    }
    
    /// <summary>An array of detail error codes, and messages, and URLs to documentation to help remediation.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBErrorResponse1 
    {
        /// <summary>High level textual error code, to help categorize the errors.</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string Code { get; set; }
    
        /// <summary>A unique reference for the error instance, for audit purposes, in case of unknown/unclassified errors.</summary>
        [Newtonsoft.Json.JsonProperty("Id", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(40, MinimumLength = 1)]
        public string Id { get; set; }
    
        /// <summary>Brief Error message, e.g., 'There is something wrong with the request parameters provided'</summary>
        [Newtonsoft.Json.JsonProperty("Message", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(500, MinimumLength = 1)]
        public string Message { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Errors", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OBError1> Errors { get; set; } = new System.Collections.ObjectModel.Collection<OBError1>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBErrorResponse1 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBErrorResponse1>(data);
        }
    
    }
    
    /// <summary>Links relevant to the payload</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Links 
    {
        [Newtonsoft.Json.JsonProperty("Self", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.Uri Self { get; set; }
    
        [Newtonsoft.Json.JsonProperty("First", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri First { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Prev", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Prev { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Next", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Next { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Last", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Uri Last { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Links FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Links>(data);
        }
    
    }
    
    /// <summary>Meta Data relevant to the payload</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Meta 
    {
        [Newtonsoft.Json.JsonProperty("TotalPages", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public int? TotalPages { get; set; }
    
        [Newtonsoft.Json.JsonProperty("FirstAvailableDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? FirstAvailableDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("LastAvailableDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? LastAvailableDateTime { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Meta FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Meta>(data);
        }
    
    }
    
    /// <summary>The Risk section is sent by the initiating party to the ASPSP. It is used to specify additional details for risk scoring for Account Info.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OBRisk2 
    {
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OBRisk2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OBRisk2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProductDetails 
    {
        /// <summary>Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.
        /// 
        /// Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd 
        /// With respect to BCA products, they are segmented in relation to different markets that they wish to focus on. </summary>
        [Newtonsoft.Json.JsonProperty("Segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Segment> Segment { get; set; }
    
        /// <summary>The length/duration of the fee free period</summary>
        [Newtonsoft.Json.JsonProperty("FeeFreeLength", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeFreeLength { get; set; }
    
        /// <summary>The unit of period (days, weeks, months etc.) of the promotional length</summary>
        [Newtonsoft.Json.JsonProperty("FeeFreeLengthPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeFreeLengthPeriod? FeeFreeLengthPeriod { get; set; }
    
        /// <summary>Optional additional notes to supplement the Core product details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ProductDetails FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProductDetails>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CreditInterest 
    {
        /// <summary>The group of tiers or bands for which credit interest can be applied.</summary>
        [Newtonsoft.Json.JsonProperty("TierBandSet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TierBandSet> TierBandSet { get; set; } = new System.Collections.ObjectModel.Collection<TierBandSet>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static CreditInterest FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CreditInterest>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Overdraft 
    {
        /// <summary>Associated Notes about the overdraft rates</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Tier band set details</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftTierBandSet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftTierBandSet> OverdraftTierBandSet { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftTierBandSet>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Overdraft FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Overdraft>(data);
        }
    
    }
    
    /// <summary>Contains details of fees and charges which are not associated with either Overdraft or features/benefits</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeesCharges 
    {
        /// <summary>TariffType which defines the fee and charges.</summary>
        [Newtonsoft.Json.JsonProperty("TariffType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TariffType? TariffType { get; set; }
    
        /// <summary>Name of the tariff</summary>
        [Newtonsoft.Json.JsonProperty("TariffName", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string TariffName { get; set; }
    
        /// <summary>Other tariff type which is not in the standard list.</summary>
        [Newtonsoft.Json.JsonProperty("OtherTariffType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherTariffType OtherTariffType { get; set; }
    
        /// <summary>Other fees/charges details</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeChargeDetail> FeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<FeeChargeDetail>();
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular or group of fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FeeChargeCap> FeeChargeCap { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeesCharges FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeesCharges>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProductDetails2 
    {
        /// <summary>Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.
        /// 
        /// Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd 
        /// With respect to PCA products, they are segmented in relation to different markets that they wish to focus on. </summary>
        [Newtonsoft.Json.JsonProperty("Segment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public System.Collections.Generic.ICollection<Segment2> Segment { get; set; }
    
        /// <summary>The maximum relevant charges that could accrue as defined fully in Part 7 of the CMA order</summary>
        [Newtonsoft.Json.JsonProperty("MonthlyMaximumCharge", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string MonthlyMaximumCharge { get; set; }
    
        /// <summary>Optional additional notes to supplement the Core product details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ProductDetails2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProductDetails2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class CreditInterest2 
    {
        /// <summary>The group of tiers or bands for which credit interest can be applied.</summary>
        [Newtonsoft.Json.JsonProperty("TierBandSet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TierBandSet2> TierBandSet { get; set; } = new System.Collections.ObjectModel.Collection<TierBandSet2>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static CreditInterest2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<CreditInterest2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Overdraft2 
    {
        /// <summary>Associated Notes about the overdraft rates</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Tier band set details</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftTierBandSet", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftTierBandSet2> OverdraftTierBandSet { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftTierBandSet2>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Overdraft2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Overdraft2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeesCharges2 
    {
        /// <summary>Other fees/charges details</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeChargeDetail2> FeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<FeeChargeDetail2>();
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FeeChargeCap2> FeeChargeCap { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeesCharges2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeesCharges2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data 
    {
        /// <summary>Unambiguous identification of the account to which credit and debit entries are made.</summary>
        [Newtonsoft.Json.JsonProperty("Account", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBAccount3> Account { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data2 
    {
        /// <summary>Set of elements used to define the balance details.</summary>
        [Newtonsoft.Json.JsonProperty("Balance", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OBCashBalance1> Balance { get; set; } = new System.Collections.ObjectModel.Collection<OBCashBalance1>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data3 
    {
        [Newtonsoft.Json.JsonProperty("Beneficiary", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBBeneficiary3> Beneficiary { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data4 
    {
        /// <summary>Unique identification as assigned to identify the account access consent resource.</summary>
        [Newtonsoft.Json.JsonProperty("ConsentId", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(128, MinimumLength = 1)]
        public string ConsentId { get; set; }
    
        /// <summary>Date and time at which the resource was created.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("CreationDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset CreationDateTime { get; set; }
    
        [Newtonsoft.Json.JsonProperty("Status", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OBExternalRequestStatus1Code Status { get; set; }
    
        /// <summary>Date and time at which the resource status was updated.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("StatusUpdateDateTime", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        public System.DateTimeOffset StatusUpdateDateTime { get; set; }
    
        /// <summary>Specifies the Open Banking account access data types. This is a list of the data clusters being consented by the PSU, and requested for authorisation with the ASPSP.</summary>
        [Newtonsoft.Json.JsonProperty("Permissions", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OBExternalPermissions1Code> Permissions { get; set; } = new System.Collections.ObjectModel.Collection<OBExternalPermissions1Code>();
    
        /// <summary>Specified date and time the permissions will expire.
        /// If this is not populated, the permissions will be open ended.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("ExpirationDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? ExpirationDateTime { get; set; }
    
        /// <summary>Specified start date and time for the transaction query period.
        /// If this is not populated, the start date will be open ended, and data will be returned from the earliest available transaction.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("TransactionFromDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TransactionFromDateTime { get; set; }
    
        /// <summary>Specified end date and time for the transaction query period.
        /// If this is not populated, the end date will be open ended, and data will be returned to the latest available transaction.
        /// All dates in the JSON payloads are represented in ISO 8601 date-time format. 
        /// All date-time fields in responses must include the timezone. An example is below:
        /// 2017-04-05T10:43:07+00:00</summary>
        [Newtonsoft.Json.JsonProperty("TransactionToDateTime", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.DateTimeOffset? TransactionToDateTime { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data5 
    {
        /// <summary>Account to or from which a cash entry is made.</summary>
        [Newtonsoft.Json.JsonProperty("DirectDebit", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBDirectDebit1> DirectDebit { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data5>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data6 
    {
        [Newtonsoft.Json.JsonProperty("Offer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBOffer1> Offer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data6>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data7 
    {
        [Newtonsoft.Json.JsonProperty("Party", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OBParty1 Party { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data7>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data8 
    {
        [Newtonsoft.Json.JsonProperty("Product", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBProduct2> Product { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data8>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data9 
    {
        [Newtonsoft.Json.JsonProperty("ScheduledPayment", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBScheduledPayment2> ScheduledPayment { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data9 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data9>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data10 
    {
        [Newtonsoft.Json.JsonProperty("StandingOrder", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStandingOrder4> StandingOrder { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data10 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data10>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data11 
    {
        /// <summary>Provides further details on a statement resource.</summary>
        [Newtonsoft.Json.JsonProperty("Statement", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBStatement1> Statement { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data11 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data11>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class Data12 
    {
        /// <summary>Provides further details on an entry in the report.</summary>
        [Newtonsoft.Json.JsonProperty("Transaction", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OBTransaction4> Transaction { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static Data12 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<Data12>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProprietaryBankTransactionCode 
    {
        /// <summary>Proprietary bank transaction code to identify the underlying transaction.</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Code { get; set; }
    
        /// <summary>Identification of the issuer of the proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("Issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Issuer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ProprietaryBankTransactionCode FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProprietaryBankTransactionCode>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProprietaryBankTransactionCode2 
    {
        /// <summary>Proprietary bank transaction code to identify the underlying transaction.</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Code { get; set; }
    
        /// <summary>Identification of the issuer of the proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("Issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Issuer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ProprietaryBankTransactionCode2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProprietaryBankTransactionCode2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class ProprietaryBankTransactionCode3 
    {
        /// <summary>Proprietary bank transaction code to identify the underlying transaction.</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Code { get; set; }
    
        /// <summary>Identification of the issuer of the proprietary bank transaction code.</summary>
        [Newtonsoft.Json.JsonProperty("Issuer", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Issuer { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static ProprietaryBankTransactionCode3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<ProprietaryBankTransactionCode3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CreditDebitIndicator8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Credit")]
        Credit = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Debit")]
        Debit = 1,
    
    }
    
    /// <summary>Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.
    /// 
    /// Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd 
    /// With respect to BCA products, they are segmented in relation to different markets that they wish to focus on. </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Segment
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ClientAccount")]
        ClientAccount = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Standard")]
        Standard = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NonCommercialChaitiesClbSoc")]
        NonCommercialChaitiesClbSoc = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"NonCommercialPublicAuthGovt")]
        NonCommercialPublicAuthGovt = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Religious")]
        Religious = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SectorSpecific")]
        SectorSpecific = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Startup")]
        Startup = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Switcher")]
        Switcher = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeFreeLengthPeriod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>The group of tiers or bands for which credit interest can be applied.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TierBandSet 
    {
        /// <summary>The methodology of how credit interest is paid/applied. It can be:-
        /// 
        /// 1. Banded
        /// Interest rates are banded. i.e. Increasing rate on whole balance as balance increases.
        /// 
        /// 2. Tiered
        /// Interest rates are tiered. i.e. increasing rate for each tier as balance increases, but interest paid on tier fixed for that tier and not on whole balance.
        /// 
        /// 3. Whole
        /// The same interest rate is applied irrespective of the BCA balance</summary>
        [Newtonsoft.Json.JsonProperty("TierBandMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TierBandMethod TierBandMethod { get; set; }
    
        /// <summary>Methods of calculating interest</summary>
        [Newtonsoft.Json.JsonProperty("CalculationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationMethod? CalculationMethod { get; set; }
    
        /// <summary>Describes whether accrued interest is payable only to the BCA or to another bank account</summary>
        [Newtonsoft.Json.JsonProperty("Destination", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Destination Destination { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier Band Set details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Tier Band Details</summary>
        [Newtonsoft.Json.JsonProperty("TierBand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TierBand> TierBand { get; set; } = new System.Collections.ObjectModel.Collection<TierBand>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TierBandSet FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TierBandSet>(data);
        }
    
    }
    
    /// <summary>Tier band set details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftTierBandSet 
    {
        /// <summary>The methodology of how overdraft is charged. It can be:
        /// 'Whole'  Where the same charge/rate is applied to the entirety of the overdraft balance (where charges are applicable). 
        /// 'Tiered' Where different charges/rates are applied dependent on overdraft maximum and minimum balance amount tiers defined by the lending financial organisation
        /// 'Banded' Where different charges/rates are applied dependent on overdraft maximum and minimum balance amount bands defined by a government organisation.</summary>
        [Newtonsoft.Json.JsonProperty("TierBandMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TierBandMethod2 TierBandMethod { get; set; }
    
        /// <summary>An overdraft can either be 'committed' which means that the facility cannot be withdrawn without reasonable notification before it's agreed end date, or 'on demand' which means that the financial institution can demand repayment at any point in time.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OverdraftType? OverdraftType { get; set; }
    
        /// <summary>Unique and unambiguous identification of a  Tier Band for a overdraft product.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Indicates if the Overdraft is authorised (Y) or unauthorised (N)</summary>
        [Newtonsoft.Json.JsonProperty("AuthorisedIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AuthorisedIndicator { get; set; }
    
        /// <summary>When a customer exceeds their credit limit, a financial institution will not charge the customer unauthorised overdraft charges if they do not exceed by more than the buffer amount. Note: Authorised overdraft charges may still apply.</summary>
        [Newtonsoft.Json.JsonProperty("BufferAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string BufferAmount { get; set; }
    
        /// <summary>Optional additional notes to supplement the overdraft Tier Band Set details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Provides overdraft details for a specific tier or band</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftTierBand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftTierBand> OverdraftTierBand { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftTierBand>();
    
        /// <summary>Overdraft fees and charges details</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeesCharges> OverdraftFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftTierBandSet FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftTierBandSet>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TariffType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Electronic")]
        Electronic = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Mixed")]
        Mixed = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherTariffType 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherTariffType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherTariffType>(data);
        }
    
    }
    
    /// <summary>Other fees/charges details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeDetail 
    {
        /// <summary>Categorisation of fees and charges into standard categories.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCategory", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeCategory FeeCategory { get; set; }
    
        /// <summary>Fee/Charge Type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType FeeType { get; set; }
    
        /// <summary>Fee/charge which is usually negotiable rather than a fixed amount</summary>
        [Newtonsoft.Json.JsonProperty("NegotiableIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NegotiableIndicator { get; set; }
    
        /// <summary>Fee Amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for Fee/Charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for Fee/Charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType? FeeRateType { get; set; }
    
        /// <summary>How frequently the fee/charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency ApplicationFrequency { get; set; }
    
        /// <summary>How frequently the fee/charge is calculated</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency? CalculationFrequency { get; set; }
    
        /// <summary>Optional additional notes to supplement the fee/charge details.</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular or group of fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FeeChargeCap3> FeeChargeCap { get; set; }
    
        [Newtonsoft.Json.JsonProperty("OtherFeeCategoryType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeCategoryType OtherFeeCategoryType { get; set; }
    
        /// <summary>Other Fee/charge type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies not covered in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency OtherCalculationFrequency { get; set; }
    
        /// <summary>Range or amounts or rates for which the fee/charge applies</summary>
        [Newtonsoft.Json.JsonProperty("FeeApplicableRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FeeApplicableRange FeeApplicableRange { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeDetail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeDetail>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular or group of fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeCap 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType2> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType2>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod? CappingPeriod { get; set; }
    
        /// <summary>Free text for adding  extra details for fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType2> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeCap FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeCap>(data);
        }
    
    }
    
    /// <summary>Market segmentation is a marketing term referring to the aggregating of prospective buyers into groups, or segments, that have common needs and respond similarly to a marketing action. Market segmentation enables companies to target different categories of consumers who perceive the full value of certain products and services differently from one another.
    /// 
    /// Read more: Market Segmentation http://www.investopedia.com/terms/m/marketsegmentation.asp#ixzz4gfEEalTd 
    /// With respect to PCA products, they are segmented in relation to different markets that they wish to focus on. </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Segment2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Basic")]
        Basic = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BenefitAndReward")]
        BenefitAndReward = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"CreditInterest")]
        CreditInterest = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Cashback")]
        Cashback = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"General")]
        General = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Graduate")]
        Graduate = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Overdraft")]
        Overdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Packaged")]
        Packaged = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Premium")]
        Premium = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Reward")]
        Reward = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Student")]
        Student = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"YoungAdult")]
        YoungAdult = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Youth")]
        Youth = 13,
    
    }
    
    /// <summary>The group of tiers or bands for which credit interest can be applied.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TierBandSet2 
    {
        /// <summary>The methodology of how credit interest is charged. It can be:-
        /// 
        /// 1. Banded
        /// Interest rates are banded. i.e. Increasing rate on whole balance as balance increases.
        /// 
        /// 2. Tiered
        /// Interest rates are tiered. i.e. increasing rate for each tier as balance increases, but interest paid on tier fixed for that tier and not on whole balance.
        /// 
        /// 3. Whole
        /// The same interest rate is applied irrespective of the PCA balance</summary>
        [Newtonsoft.Json.JsonProperty("TierBandMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TierBandMethod3 TierBandMethod { get; set; }
    
        /// <summary>Methods of calculating interest</summary>
        [Newtonsoft.Json.JsonProperty("CalculationMethod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationMethod2? CalculationMethod { get; set; }
    
        /// <summary>Describes whether accrued interest is payable only to the PCA or to another bank account</summary>
        [Newtonsoft.Json.JsonProperty("Destination", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public Destination2? Destination { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier Band Set details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Tier Band Details</summary>
        [Newtonsoft.Json.JsonProperty("TierBand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<TierBand2> TierBand { get; set; } = new System.Collections.ObjectModel.Collection<TierBand2>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TierBandSet2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TierBandSet2>(data);
        }
    
    }
    
    /// <summary>Tier band set details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftTierBandSet2 
    {
        /// <summary>The methodology of how overdraft is charged. It can be:
        /// 'Whole'  Where the same charge/rate is applied to the entirety of the overdraft balance (where charges are applicable). 
        /// 'Tiered' Where different charges/rates are applied dependent on overdraft maximum and minimum balance amount tiers defined by the lending financial organisation
        /// 'Banded' Where different charges/rates are applied dependent on overdraft maximum and minimum balance amount bands defined by a government organisation.</summary>
        [Newtonsoft.Json.JsonProperty("TierBandMethod", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public TierBandMethod4 TierBandMethod { get; set; }
    
        /// <summary>An overdraft can either be 'committed' which means that the facility cannot be withdrawn without reasonable notification before it's agreed end date, or 'on demand' which means that the financial institution can demand repayment at any point in time.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OverdraftType2? OverdraftType { get; set; }
    
        /// <summary>Unique and unambiguous identification of a  Tier Band for a overdraft product.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Indicates if the Overdraft is authorised (Y) or unauthorised (N)</summary>
        [Newtonsoft.Json.JsonProperty("AuthorisedIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? AuthorisedIndicator { get; set; }
    
        /// <summary>When a customer exceeds their credit limit, a financial institution will not charge the customer unauthorised overdraft charges if they do not exceed by more than the buffer amount. Note: Authorised overdraft charges may still apply.</summary>
        [Newtonsoft.Json.JsonProperty("BufferAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string BufferAmount { get; set; }
    
        /// <summary>Optional additional notes to supplement the overdraft Tier Band Set details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Provides overdraft details for a specific tier or band</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftTierBand", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftTierBand2> OverdraftTierBand { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftTierBand2>();
    
        /// <summary>Overdraft fees and charges details</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeesCharges2> OverdraftFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftTierBandSet2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftTierBandSet2>(data);
        }
    
    }
    
    /// <summary>Other fees/charges details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeDetail2 
    {
        /// <summary>Categorisation of fees and charges into standard categories.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCategory", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeCategory2 FeeCategory { get; set; }
    
        /// <summary>Fee/Charge Type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType3 FeeType { get; set; }
    
        /// <summary>Fee Amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for Fee/Charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for Fee/Charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType2? FeeRateType { get; set; }
    
        /// <summary>How frequently the fee/charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency2 ApplicationFrequency { get; set; }
    
        /// <summary>How frequently the fee/charge is calculated</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency2? CalculationFrequency { get; set; }
    
        /// <summary>Optional additional notes to supplement the fee/charge details.</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        [Newtonsoft.Json.JsonProperty("OtherFeeCategoryType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeCategoryType2 OtherFeeCategoryType { get; set; }
    
        /// <summary>Other Fee/charge type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType3 OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType2 OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies not covered in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency2 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency2 OtherCalculationFrequency { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<FeeChargeCap4> FeeChargeCap { get; set; }
    
        /// <summary>Range or amounts or rates for which the fee/charge applies</summary>
        [Newtonsoft.Json.JsonProperty("FeeApplicableRange", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public FeeApplicableRange2 FeeApplicableRange { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeDetail2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeDetail2>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeCap2 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType4> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType4>();
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType2 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod2? CappingPeriod { get; set; }
    
        /// <summary>Free text for adding  extra details for fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType4> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeCap2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeCap2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TierBandMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Banded")]
        Banded = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationMethod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Compound")]
        Compound = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SimpleInterest")]
        SimpleInterest = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Destination
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PayAway")]
        PayAway = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SelfCredit")]
        SelfCredit = 1,
    
    }
    
    /// <summary>Tier Band Details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TierBand 
    {
        /// <summary>Unique and unambiguous identification of a  Tier Band for a BCA.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Minimum deposit value for which the credit interest tier applies.</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMinimum", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMinimum { get; set; }
    
        /// <summary>Maximum deposit value for which the credit interest tier applies.</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMaximum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMaximum { get; set; }
    
        /// <summary>How often is credit interest calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency3? CalculationFrequency { get; set; }
    
        /// <summary>How often is interest applied to the BCA for this tier/band i.e. how often the financial institution pays accumulated interest to the customer's BCA.</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency3 ApplicationFrequency { get; set; }
    
        /// <summary>Amount on which Interest applied.</summary>
        [Newtonsoft.Json.JsonProperty("DepositInterestAppliedCoverage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DepositInterestAppliedCoverage? DepositInterestAppliedCoverage { get; set; }
    
        /// <summary>Type of interest rate, Fixed or Variable</summary>
        [Newtonsoft.Json.JsonProperty("FixedVariableInterestRateType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FixedVariableInterestRateType FixedVariableInterestRateType { get; set; }
    
        /// <summary>The annual equivalent rate (AER) is interest that is calculated under the assumption that any interest paid is combined with the original balance and the next interest payment will be based on the slightly higher account balance. Overall, this means that interest can be compounded several times in a year depending on the number of times that interest payments are made. 
        /// 
        /// Read more: Annual Equivalent Rate (AER) http://www.investopedia.com/terms/a/aer.asp#ixzz4gfR7IO1A</summary>
        [Newtonsoft.Json.JsonProperty("AER", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string AER { get; set; }
    
        /// <summary>Interest rate types, other than AER, which financial institutions may use to describe the annual interest rate payable to the BCA.</summary>
        [Newtonsoft.Json.JsonProperty("BankInterestRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BankInterestRateType? BankInterestRateType { get; set; }
    
        /// <summary>Bank Interest for the BCA product</summary>
        [Newtonsoft.Json.JsonProperty("BankInterestRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string BankInterestRate { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier Band details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other interest rate types which are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherBankInterestType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherBankInterestType OtherBankInterestType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency3 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency3 OtherCalculationFrequency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TierBand FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TierBand>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TierBandMethod2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Banded")]
        Banded = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OverdraftType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Committed")]
        Committed = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnDemand")]
        OnDemand = 1,
    
    }
    
    /// <summary>Provides overdraft details for a specific tier or band</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftTierBand 
    {
        /// <summary>Unique and unambiguous identification of a  Tier Band for a overdraft.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Minimum value of Overdraft Tier/Band</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMin { get; set; }
    
        /// <summary>Maximum value of Overdraft Tier/Band</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMax { get; set; }
    
        /// <summary>EAR means Effective Annual Rate and/or Equivalent Annual Rate (frequently
        /// used interchangeably), being the actual annual interest rate of an Overdraft.</summary>
        [Newtonsoft.Json.JsonProperty("EAR", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string EAR { get; set; }
    
        /// <summary>Specifies the minimum length of a band for a fixed overdraft agreement</summary>
        [Newtonsoft.Json.JsonProperty("AgreementLengthMin", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AgreementLengthMin { get; set; }
    
        /// <summary>Specifies the maximum length of a band for a fixed overdraft agreement</summary>
        [Newtonsoft.Json.JsonProperty("AgreementLengthMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? AgreementLengthMax { get; set; }
    
        /// <summary>Specifies the period of a fixed length overdraft agreement</summary>
        [Newtonsoft.Json.JsonProperty("AgreementPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public AgreementPeriod? AgreementPeriod { get; set; }
    
        /// <summary>Refers to which interest rate is applied when interests are tiered. For example, if an overdraft balance is £2k and the interest tiers are:- 0-£500 0.1%, 500-1000 0.2%, 1000-10000 0.5%, then the applicable interest rate could either be 0.5% of the entire balance (since the account balance sits in the top interest tier) or (0.1%*500)+(0.2%*500)+(0.5%*1000). In the 1st situation, we say the interest is applied to the ‘Whole’ of the account balance,  and in the 2nd that it is ‘Tiered’.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftInterestChargingCoverage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OverdraftInterestChargingCoverage? OverdraftInterestChargingCoverage { get; set; }
    
        /// <summary>Indicates whether the advertised overdraft rate is guaranteed to be offered to a borrower by the bank e.g. if it’s part of a government scheme, or whether the rate may vary dependent on the applicant’s circumstances.</summary>
        [Newtonsoft.Json.JsonProperty("BankGuaranteedIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BankGuaranteedIndicator { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier/band details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Overdraft fees and charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeesCharges3> OverdraftFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftTierBand FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftTierBand>(data);
        }
    
    }
    
    /// <summary>Overdraft fees and charges details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeesCharges 
    {
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Details about the fees/charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeDetail> OverdraftFeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftFeeChargeDetail>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeesCharges FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeesCharges>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeCategory
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Servicing")]
        Servicing = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeQuarterly")]
        ServiceCAccountFeeQuarterly = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCFixedTariff")]
        ServiceCFixedTariff = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCBusiDepAccBreakage")]
        ServiceCBusiDepAccBreakage = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCMinimumMonthlyFee")]
        ServiceCMinimumMonthlyFee = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular or group of fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeCap3 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType5> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType5>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType3 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod3? CappingPeriod { get; set; }
    
        /// <summary>Free text for adding  extra details for fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType5> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeCap3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeCap3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeCategoryType 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeCategoryType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeCategoryType>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Categorisation of fees and charges into standard categories.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCategory", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeCategory3 FeeCategory { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeApplicableRange 
    {
        /// <summary>Minimum Amount on which fee/charge is applicable (where it is expressed as an amount)</summary>
        [Newtonsoft.Json.JsonProperty("MinimumAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string MinimumAmount { get; set; }
    
        /// <summary>Maximum Amount on which fee is applicable (where it is expressed as an amount)</summary>
        [Newtonsoft.Json.JsonProperty("MaximumAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string MaximumAmount { get; set; }
    
        /// <summary>Minimum rate on which fee/charge is applicable(where it is expressed as an rate)</summary>
        [Newtonsoft.Json.JsonProperty("MinimumRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string MinimumRate { get; set; }
    
        /// <summary>Maximum rate on which fee/charge is applicable(where it is expressed as an rate)</summary>
        [Newtonsoft.Json.JsonProperty("MaximumRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string MaximumRate { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeApplicableRange FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeApplicableRange>(data);
        }
    
    }
    
    /// <summary>Fee/charge type which is being capped</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeQuarterly")]
        ServiceCAccountFeeQuarterly = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCFixedTariff")]
        ServiceCFixedTariff = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCBusiDepAccBreakage")]
        ServiceCBusiDepAccBreakage = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCMinimumMonthlyFee")]
        ServiceCMinimumMonthlyFee = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TierBandMethod3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationMethod2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Compound")]
        Compound = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SimpleInterest")]
        SimpleInterest = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum Destination2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PayAway")]
        PayAway = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SelfCredit")]
        SelfCredit = 1,
    
    }
    
    /// <summary>Tier Band Details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class TierBand2 
    {
        /// <summary>Unique and unambiguous identification of a  Tier Band for a PCA.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Minimum deposit value for which the credit interest tier applies.</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMinimum", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMinimum { get; set; }
    
        /// <summary>Maximum deposit value for which the credit interest tier applies.</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMaximum", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMaximum { get; set; }
    
        /// <summary>How often is credit interest calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency4? CalculationFrequency { get; set; }
    
        /// <summary>How often is interest applied to the PCA for this tier/band i.e. how often the financial institution pays accumulated interest to the customer's PCA.</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency4 ApplicationFrequency { get; set; }
    
        /// <summary>Amount on which Interest applied.</summary>
        [Newtonsoft.Json.JsonProperty("DepositInterestAppliedCoverage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public DepositInterestAppliedCoverage2? DepositInterestAppliedCoverage { get; set; }
    
        /// <summary>Type of interest rate, Fixed or Variable</summary>
        [Newtonsoft.Json.JsonProperty("FixedVariableInterestRateType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FixedVariableInterestRateType2 FixedVariableInterestRateType { get; set; }
    
        /// <summary>The annual equivalent rate (AER) is interest that is calculated under the assumption that any interest paid is combined with the original balance and the next interest payment will be based on the slightly higher account balance. Overall, this means that interest can be compounded several times in a year depending on the number of times that interest payments are made. 
        /// 
        /// Read more: Annual Equivalent Rate (AER) http://www.investopedia.com/terms/a/aer.asp#ixzz4gfR7IO1A</summary>
        [Newtonsoft.Json.JsonProperty("AER", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string AER { get; set; }
    
        /// <summary>Interest rate types, other than AER, which financial institutions may use to describe the annual interest rate payable to the PCA.</summary>
        [Newtonsoft.Json.JsonProperty("BankInterestRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public BankInterestRateType2? BankInterestRateType { get; set; }
    
        /// <summary>Bank Interest for the PCA product</summary>
        [Newtonsoft.Json.JsonProperty("BankInterestRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string BankInterestRate { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier Band details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other interest rate types which are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherBankInterestType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherBankInterestType2 OtherBankInterestType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency4 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency4 OtherCalculationFrequency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static TierBand2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<TierBand2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum TierBandMethod4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Banded")]
        Banded = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OverdraftType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Committed")]
        Committed = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnDemand")]
        OnDemand = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 2,
    
    }
    
    /// <summary>Provides overdraft details for a specific tier or band</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftTierBand2 
    {
        /// <summary>Unique and unambiguous identification of a  Tier Band for a overdraft.</summary>
        [Newtonsoft.Json.JsonProperty("Identification", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(35, MinimumLength = 1)]
        public string Identification { get; set; }
    
        /// <summary>Minimum value of Overdraft Tier/Band</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMin", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMin { get; set; }
    
        /// <summary>Maximum value of Overdraft Tier/Band</summary>
        [Newtonsoft.Json.JsonProperty("TierValueMax", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string TierValueMax { get; set; }
    
        /// <summary>Interest charged on whole amount or tiered/banded</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftInterestChargingCoverage", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public OverdraftInterestChargingCoverage2? OverdraftInterestChargingCoverage { get; set; }
    
        /// <summary>Indicates that a bank provides the overdraft limit up to TierValueMIn to all customers automatically</summary>
        [Newtonsoft.Json.JsonProperty("BankGuaranteedIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? BankGuaranteedIndicator { get; set; }
    
        /// <summary>EAR means Effective Annual Rate and/or Equivalent Annual Rate (frequently
        /// used interchangeably), being the actual annual interest rate of an Overdraft.</summary>
        [Newtonsoft.Json.JsonProperty("EAR", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string EAR { get; set; }
    
        /// <summary>Optional additional notes to supplement the Tier/band details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Overdraft fees and charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeesCharges", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeesCharges4> OverdraftFeesCharges { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftTierBand2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftTierBand2>(data);
        }
    
    }
    
    /// <summary>Overdraft fees and charges details</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeesCharges2 
    {
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap2> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Details about the fees/charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeDetail2> OverdraftFeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftFeeChargeDetail2>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeesCharges2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeesCharges2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeCategory2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Servicing")]
        Servicing = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LinkedBaseRate")]
        LinkedBaseRate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Net")]
        Net = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeCategoryType2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeCategoryType2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeCategoryType2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType3 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Categorisation of fees and charges into standard categories.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCategory", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeCategory4 FeeCategory { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency2>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeChargeCap4 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType6> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType6>();
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType4 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod4? CappingPeriod { get; set; }
    
        /// <summary>Free text for adding  extra details for fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType6> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeChargeCap4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeChargeCap4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class FeeApplicableRange2 
    {
        /// <summary>Minimum Amount on which fee/charge is applicable (where it is expressed as an amount)</summary>
        [Newtonsoft.Json.JsonProperty("MinimumAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string MinimumAmount { get; set; }
    
        /// <summary>Maximum Amount on which fee is applicable (where it is expressed as an amount)</summary>
        [Newtonsoft.Json.JsonProperty("MaximumAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string MaximumAmount { get; set; }
    
        /// <summary>Minimum rate on which fee/charge is applicable(where it is expressed as an rate)</summary>
        [Newtonsoft.Json.JsonProperty("MinimumRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string MinimumRate { get; set; }
    
        /// <summary>Maximum rate on which fee/charge is applicable(where it is expressed as an rate)</summary>
        [Newtonsoft.Json.JsonProperty("MaximumRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string MaximumRate { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static FeeApplicableRange2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<FeeApplicableRange2>(data);
        }
    
    }
    
    /// <summary>Fee/charge type which is being capped</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType4 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HalfYearly")]
        HalfYearly = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerStatementDate")]
        PerStatementDate = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HalfYearly")]
        HalfYearly = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerStatementDate")]
        PerStatementDate = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DepositInterestAppliedCoverage
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Banded")]
        Banded = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 2,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixedVariableInterestRateType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Fixed")]
        Fixed = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Variable")]
        Variable = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BankInterestRateType
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherBankInterestType 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherBankInterestType FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherBankInterestType>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency3 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency3 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum AgreementPeriod
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OverdraftInterestChargingCoverage
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Banded")]
        Banded = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 2,
    
    }
    
    /// <summary>Overdraft fees and charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeesCharges3 
    {
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap3> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Details about the fees/charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeDetail3> OverdraftFeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftFeeChargeDetail3>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeesCharges3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeesCharges3>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType7> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType7>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType5 MinMaxType { get; set; }
    
        /// <summary>Indicates whether the advertised overdraft rate is guaranteed to be offered to a borrower by the bank e.g. if it’s part of a government scheme, or whether the rate may vary dependent on the applicant’s circumstances.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod5? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType7> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap>(data);
        }
    
    }
    
    /// <summary>Details about the fees/charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeDetail 
    {
        /// <summary>Overdraft fee type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType8 FeeType { get; set; }
    
        /// <summary>Indicates whether fee and charges are negotiable</summary>
        [Newtonsoft.Json.JsonProperty("NegotiableIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NegotiableIndicator { get; set; }
    
        /// <summary>Indicates if the fee/charge is already covered by an 'Overdraft Control' fee or not.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Every additional tranche of an overdraft balance to which an overdraft fee is applied</summary>
        [Newtonsoft.Json.JsonProperty("IncrementalBorrowingAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string IncrementalBorrowingAmount { get; set; }
    
        /// <summary>Amount charged for an overdraft fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType3? FeeRateType { get; set; }
    
        /// <summary>Frequency at which the overdraft charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency5 ApplicationFrequency { get; set; }
    
        /// <summary>How often is the overdraft fee/charge calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency5? CalculationFrequency { get; set; }
    
        /// <summary>Free text for capturing any other info related to Overdraft Fees Charge Details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap4> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Other Fee type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType8 OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType3 OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency5 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency5 OtherCalculationFrequency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeDetail FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeDetail>(data);
        }
    
    }
    
    /// <summary>Fee/charge type which is being capped</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeQuarterly")]
        ServiceCAccountFeeQuarterly = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCFixedTariff")]
        ServiceCFixedTariff = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCBusiDepAccBreakage")]
        ServiceCBusiDepAccBreakage = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCMinimumMonthlyFee")]
        ServiceCMinimumMonthlyFee = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 7,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType5 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType5>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeCategory3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Servicing")]
        Servicing = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PerAcademicTerm")]
        PerAcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HalfYearly")]
        HalfYearly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerStatementDate")]
        PerStatementDate = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"PerAcademicTerm")]
        PerAcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"HalfYearly")]
        HalfYearly = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerStatementDate")]
        PerStatementDate = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 8,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum DepositInterestAppliedCoverage2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FixedVariableInterestRateType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Fixed")]
        Fixed = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Variable")]
        Variable = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum BankInterestRateType2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LinkedBaseRate")]
        LinkedBaseRate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Net")]
        Net = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherBankInterestType2 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherBankInterestType2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherBankInterestType2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency4 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency4 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum OverdraftInterestChargingCoverage2
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Tiered")]
        Tiered = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Whole")]
        Whole = 1,
    
    }
    
    /// <summary>Overdraft fees and charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeesCharges4 
    {
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap5> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Details about the fees/charges</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeDetail", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeDetail4> OverdraftFeeChargeDetail { get; set; } = new System.Collections.ObjectModel.Collection<OverdraftFeeChargeDetail4>();
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeesCharges4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeesCharges4>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap2 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType9> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType9>();
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType6 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod6? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType9> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap2>(data);
        }
    
    }
    
    /// <summary>Details about the fees/charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeDetail2 
    {
        /// <summary>Overdraft fee type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType10 FeeType { get; set; }
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Every additional tranche of an overdraft balance to which an overdraft fee is applied</summary>
        [Newtonsoft.Json.JsonProperty("IncrementalBorrowingAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string IncrementalBorrowingAmount { get; set; }
    
        /// <summary>Amount charged for an overdraft fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType4? FeeRateType { get; set; }
    
        /// <summary>Frequency at which the overdraft charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency6 ApplicationFrequency { get; set; }
    
        /// <summary>How often is the overdraft fee/charge calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency6? CalculationFrequency { get; set; }
    
        /// <summary>Free text for capturing any other info related to Overdraft Fees Charge Details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other Fee type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType10 OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType4 OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency6 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency6 OtherCalculationFrequency { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OverdraftFeeChargeCap6 OverdraftFeeChargeCap { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeDetail2 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeDetail2>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeCategory4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Servicing")]
        Servicing = 1,
    
    }
    
    /// <summary>Fee/charge type which is being capped</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFee")]
        ServiceCAccountFee = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCAccountFeeMonthly")]
        ServiceCAccountFeeMonthly = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ServiceCOther")]
        ServiceCOther = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType6 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType6>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap3 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType11> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType11>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType7 MinMaxType { get; set; }
    
        /// <summary>Indicates whether the advertised overdraft rate is guaranteed to be offered to a borrower by the bank e.g. if it’s part of a government scheme, or whether the rate may vary dependent on the applicant’s circumstances.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod7? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType11> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap3>(data);
        }
    
    }
    
    /// <summary>Details about the fees/charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeDetail3 
    {
        /// <summary>Overdraft fee type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType12 FeeType { get; set; }
    
        /// <summary>Indicates whether fee and charges are negotiable</summary>
        [Newtonsoft.Json.JsonProperty("NegotiableIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? NegotiableIndicator { get; set; }
    
        /// <summary>Indicates if the fee/charge is already covered by an 'Overdraft Control' fee or not.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Every additional tranche of an overdraft balance to which an overdraft fee is applied</summary>
        [Newtonsoft.Json.JsonProperty("IncrementalBorrowingAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string IncrementalBorrowingAmount { get; set; }
    
        /// <summary>Amount charged for an overdraft fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType5? FeeRateType { get; set; }
    
        /// <summary>Frequency at which the overdraft charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency7 ApplicationFrequency { get; set; }
    
        /// <summary>How often is the overdraft fee/charge calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency7? CalculationFrequency { get; set; }
    
        /// <summary>Free text for capturing any other info related to Overdraft Fees Charge Details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OverdraftFeeChargeCap7> OverdraftFeeChargeCap { get; set; }
    
        /// <summary>Other Fee type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType12 OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType5 OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency7 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency7 OtherCalculationFrequency { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeDetail3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeDetail3>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType7 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType7>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType3
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap4 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType13> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType13>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType8 MinMaxType { get; set; }
    
        /// <summary>Indicates whether the advertised overdraft rate is guaranteed to be offered to a borrower by the bank e.g. if it’s part of a government scheme, or whether the rate may vary dependent on the applicant’s circumstances.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod8? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType13> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType8 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType8>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType3 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType3 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType3>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency5 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency5>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency5 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency5>(data);
        }
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap5 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType14> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType14>();
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType9 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod9? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType14> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap5>(data);
        }
    
    }
    
    /// <summary>Details about the fees/charges</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeDetail4 
    {
        /// <summary>Overdraft fee type</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeType15 FeeType { get; set; }
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Every additional tranche of an overdraft balance to which an overdraft fee is applied</summary>
        [Newtonsoft.Json.JsonProperty("IncrementalBorrowingAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string IncrementalBorrowingAmount { get; set; }
    
        /// <summary>Amount charged for an overdraft fee/charge (where it is charged in terms of an amount rather than a rate)</summary>
        [Newtonsoft.Json.JsonProperty("FeeAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeAmount { get; set; }
    
        /// <summary>Rate charged for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRate", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,3}){1}(\.\d{1,4}){0,1}$")]
        public string FeeRate { get; set; }
    
        /// <summary>Rate type for overdraft fee/charge (where it is charged in terms of a rate rather than an amount)</summary>
        [Newtonsoft.Json.JsonProperty("FeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public FeeRateType6? FeeRateType { get; set; }
    
        /// <summary>Frequency at which the overdraft charge is applied to the account</summary>
        [Newtonsoft.Json.JsonProperty("ApplicationFrequency", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public ApplicationFrequency8 ApplicationFrequency { get; set; }
    
        /// <summary>How often is the overdraft fee/charge calculated for the account.</summary>
        [Newtonsoft.Json.JsonProperty("CalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CalculationFrequency8? CalculationFrequency { get; set; }
    
        /// <summary>Free text for capturing any other info related to Overdraft Fees Charge Details</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other Fee type which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeType15 OtherFeeType { get; set; }
    
        /// <summary>Other fee rate type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeRateType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherFeeRateType6 OtherFeeRateType { get; set; }
    
        /// <summary>Other application frequencies that are not available in the standard code list</summary>
        [Newtonsoft.Json.JsonProperty("OtherApplicationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherApplicationFrequency8 OtherApplicationFrequency { get; set; }
    
        /// <summary>Other calculation frequency which is not available in the standard code set.</summary>
        [Newtonsoft.Json.JsonProperty("OtherCalculationFrequency", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OtherCalculationFrequency8 OtherCalculationFrequency { get; set; }
    
        /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftFeeChargeCap", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public OverdraftFeeChargeCap8 OverdraftFeeChargeCap { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeDetail4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeDetail4>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType9 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType9 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType9>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType4
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LinkedBaseRate")]
        LinkedBaseRate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Net")]
        Net = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType10 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType10 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType10>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType4 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType4 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType4>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency6 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency6>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency6 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency6>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap6 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType16> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType16>();
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType10 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod10? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType16> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap6>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType11 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType11 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType11>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType5
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency7
    {
        [System.Runtime.Serialization.EnumMember(Value = @"OnClosing")]
        OnClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnOpening")]
        OnOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAnniversary")]
        OnAnniversary = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHundredPounds")]
        PerHundredPounds = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    /// <summary>Details about any caps (maximum charges) that apply to a particular fee/charge. Capping can either be based on an amount (in gbp), an amount (in items) or a rate.</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap7 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType17> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType17>();
    
        /// <summary>Min Max type</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType11 MinMaxType { get; set; }
    
        /// <summary>Indicates whether the advertised overdraft rate is guaranteed to be offered to a borrower by the bank e.g. if it’s part of a government scheme, or whether the rate may vary dependent on the applicant’s circumstances.</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod11? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType17> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap7>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType12 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType12 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType12>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType5 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType5 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType5>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency7 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency7>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency7 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency7 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency7>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType13
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType13 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType13 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType13>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType14
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod9
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType14 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType14 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType14>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType15
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeRateType6
    {
        [System.Runtime.Serialization.EnumMember(Value = @"LinkedBaseRate")]
        LinkedBaseRate = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Gross")]
        Gross = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Net")]
        Net = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 3,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum ApplicationFrequency8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CalculationFrequency8
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AccountClosing")]
        AccountClosing = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AccountOpening")]
        AccountOpening = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"ChargingPeriod")]
        ChargingPeriod = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Daily")]
        Daily = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerItem")]
        PerItem = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Monthly")]
        Monthly = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OnAccountAnniversary")]
        OnAccountAnniversary = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerHour")]
        PerHour = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerOccurrence")]
        PerOccurrence = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerSheet")]
        PerSheet = 11,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransaction")]
        PerTransaction = 12,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionAmount")]
        PerTransactionAmount = 13,
    
        [System.Runtime.Serialization.EnumMember(Value = @"PerTransactionPercentage")]
        PerTransactionPercentage = 14,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarterly")]
        Quarterly = 15,
    
        [System.Runtime.Serialization.EnumMember(Value = @"SixMonthly")]
        SixMonthly = 16,
    
        [System.Runtime.Serialization.EnumMember(Value = @"StatementMonthly")]
        StatementMonthly = 17,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Weekly")]
        Weekly = 18,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Yearly")]
        Yearly = 19,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType15 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType15 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType15>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeRateType6 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeRateType6 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeRateType6>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherApplicationFrequency8 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherApplicationFrequency8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherApplicationFrequency8>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherCalculationFrequency8 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherCalculationFrequency8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherCalculationFrequency8>(data);
        }
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OverdraftFeeChargeCap8 
    {
        /// <summary>Fee/charge type which is being capped</summary>
        [Newtonsoft.Json.JsonProperty("FeeType", Required = Newtonsoft.Json.Required.Always, ItemConverterType = typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        [System.ComponentModel.DataAnnotations.Required]
        public System.Collections.Generic.ICollection<FeeType18> FeeType { get; set; } = new System.Collections.ObjectModel.Collection<FeeType18>();
    
        /// <summary>Specifies for the overdraft control feature/benefit</summary>
        [Newtonsoft.Json.JsonProperty("OverdraftControlIndicator", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public bool? OverdraftControlIndicator { get; set; }
    
        /// <summary>Indicates that this is the minimum/ maximum fee/charge that can be applied by the financial institution</summary>
        [Newtonsoft.Json.JsonProperty("MinMaxType", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required(AllowEmptyStrings = true)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public MinMaxType12 MinMaxType { get; set; }
    
        /// <summary>fee/charges are captured dependent on the number of occurrences rather than capped at a particular amount</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapOccurrence", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public double? FeeCapOccurrence { get; set; }
    
        /// <summary>Cap amount charged for a fee/charge</summary>
        [Newtonsoft.Json.JsonProperty("FeeCapAmount", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^(-?\d{1,14}){1}(\.\d{1,4}){0,1}$")]
        public string FeeCapAmount { get; set; }
    
        /// <summary>Period e.g. day, week, month etc. for which the fee/charge is capped</summary>
        [Newtonsoft.Json.JsonProperty("CappingPeriod", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
        public CappingPeriod12? CappingPeriod { get; set; }
    
        /// <summary>Notes related to Overdraft fee charge cap</summary>
        [Newtonsoft.Json.JsonProperty("Notes", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<string> Notes { get; set; }
    
        /// <summary>Other fee type code which is not available in the standard code set</summary>
        [Newtonsoft.Json.JsonProperty("OtherFeeType", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        public System.Collections.Generic.ICollection<OtherFeeType18> OtherFeeType { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OverdraftFeeChargeCap8 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OverdraftFeeChargeCap8>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType16
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod10
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType16 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType16 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType16>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType17
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod11
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 5,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType17 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType17 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType17>(data);
        }
    
    }
    
    /// <summary>Overdraft fee type</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum FeeType18
    {
        [System.Runtime.Serialization.EnumMember(Value = @"ArrangedOverdraft")]
        ArrangedOverdraft = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"EmergencyBorrowing")]
        EmergencyBorrowing = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"BorrowingItem")]
        BorrowingItem = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftRenewal")]
        OverdraftRenewal = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"AnnualReview")]
        AnnualReview = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"OverdraftSetup")]
        OverdraftSetup = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Surcharge")]
        Surcharge = 6,
    
        [System.Runtime.Serialization.EnumMember(Value = @"TempOverdraft")]
        TempOverdraft = 7,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedBorrowing")]
        UnauthorisedBorrowing = 8,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedPaidTrans")]
        UnauthorisedPaidTrans = 9,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Other")]
        Other = 10,
    
        [System.Runtime.Serialization.EnumMember(Value = @"UnauthorisedUnpaidTrans")]
        UnauthorisedUnpaidTrans = 11,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum MinMaxType12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"Minimum")]
        Minimum = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Maximum")]
        Maximum = 1,
    
    }
    
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public enum CappingPeriod12
    {
        [System.Runtime.Serialization.EnumMember(Value = @"AcademicTerm")]
        AcademicTerm = 0,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Day")]
        Day = 1,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Half Year")]
        Half_Year = 2,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Month")]
        Month = 3,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Quarter")]
        Quarter = 4,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Week")]
        Week = 5,
    
        [System.Runtime.Serialization.EnumMember(Value = @"Year")]
        Year = 6,
    
    }
    
    /// <summary>Other fee type code which is not available in the standard code set</summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "9.13.18.0 (Newtonsoft.Json v11.0.0.0)")]
    public partial class OtherFeeType18 
    {
        /// <summary>The four letter Mnemonic used within an XML file to identify a code</summary>
        [Newtonsoft.Json.JsonProperty("Code", Required = Newtonsoft.Json.Required.Default, NullValueHandling = Newtonsoft.Json.NullValueHandling.Ignore)]
        [System.ComponentModel.DataAnnotations.StringLength(4)]
        [System.ComponentModel.DataAnnotations.RegularExpression(@"^\w{0,4}$")]
        public string Code { get; set; }
    
        /// <summary>Long name associated with the code</summary>
        [Newtonsoft.Json.JsonProperty("Name", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(70, MinimumLength = 1)]
        public string Name { get; set; }
    
        /// <summary>Description to describe the purpose of the code</summary>
        [Newtonsoft.Json.JsonProperty("Description", Required = Newtonsoft.Json.Required.Always)]
        [System.ComponentModel.DataAnnotations.Required]
        [System.ComponentModel.DataAnnotations.StringLength(350, MinimumLength = 1)]
        public string Description { get; set; }
    
        public string ToJson() 
        {
            return Newtonsoft.Json.JsonConvert.SerializeObject(this);
        }
    
        public static OtherFeeType18 FromJson(string data)
        {
            return Newtonsoft.Json.JsonConvert.DeserializeObject<OtherFeeType18>(data);
        }
    
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException) 
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + response.Substring(0, response.Length >= 512 ? 512 : response.Length), innerException)
        {
            StatusCode = statusCode;
            Response = response; 
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "12.0.14.0 (NJsonSchema v9.13.18.0 (Newtonsoft.Json v11.0.0.0))")]
    public partial class SwaggerException<TResult> : SwaggerException
    {
        public TResult Result { get; private set; }

        public SwaggerException(string message, int statusCode, string response, System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException) 
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

    #pragma warning restore
}